<!DOCTYPE html>
<!--
 * Document Tools - 특허 명세서 전처리 도구
 * Version: 1.2.0
 * Last Updated: 2026-01-26
 * 
 * Copyright (c) 2026 Smart Danny. All rights reserved.
 * 이 소프트웨어는 저작권법의 보호를 받습니다.
 * 무단 복제, 배포, 수정을 금지합니다.
-->
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>문서 도구 모음</title>
    <meta name="author" content="Smart Danny">
    <meta name="version" content="1.2.0">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <!-- Markdown to PDF용 라이브러리 -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js"></script>
    <link rel="stylesheet" href="styles.css">
    <script src="utils.js"></script>
</head>
<body>
    <div class="title-section">
        <h1>📄 문서 도구 모음</h1>
        <p>첨자 변환 및 한영혼합본 도구 기능</p>
    </div>
    
    <div class="container">
        <div class="tab-nav">
            <button class="tab-btn active" onclick="switchMainTab('tab1', this)">전처리 단계 (DOCX→HTML)</button>
            <button class="tab-btn" onclick="switchMainTab('tab2', this)">후처리 단계 (HTML→DOCX)</button>
            <button class="tab-btn" onclick="switchMainTab('tab3', this)">한영혼합본 도구</button>
            <button class="tab-btn" onclick="switchMainTab('tab4', this)">문서 비교</button>
            <button class="tab-btn" onclick="switchMainTab('tab5', this)">Markdown to PDF</button>
        </div>
        
        <!-- 탭1: DOCX → HTML -->
        <div id="tab1" class="tab-content active">
            <div class="section">
                <div class="section-title">1단계: DOCX 파일 업로드</div>
                <div class="unified-input-area">
                    <div class="file-select-row">
                        <input type="file" id="fileInput1" accept=".docx" style="display:none;">
                        <button class="file-select-btn" onclick="document.getElementById('fileInput1').click()">📁 파일 선택</button>
                        <span class="file-name-display" id="fileName1">또는 아래에 .docx 파일을 드래그하세요</span>
                        <button class="btn btn-danger btn-sm" onclick="clearAll1()" style="margin-left:auto;">🗑️ 전체 지우기</button>
                    </div>
                    <textarea id="textInput1" placeholder=".docx 파일을 선택하거나 여기에 드래그하여 놓으세요..." readonly style="cursor:pointer;background:#f9f9f9;"></textarea>
                    <span class="drop-hint">📎 .docx 파일 드롭 가능</span>
                </div>
                <div class="note" style="margin-top:10px;">
                    <span class="note-icon">⚠️</span>
                    <span>.doc 파일은 Microsoft Word에서 .docx 형식으로 변환 후 업로드해 주세요.</span>
                </div>
                <div id="fileAnalysis1" class="file-analysis hidden">
                    <div class="analysis-title">📋 파일 분석 결과</div>
                    <div class="analysis-items">
                        <span class="analysis-item" id="analysisCrossRef"><span class="analysis-icon">❌</span> Cross-reference</span>
                        <span class="analysis-item" id="analysisScript"><span class="analysis-icon">❌</span> 첨자</span>
                        <span class="analysis-item" id="analysisParagraphNum"><span class="analysis-icon">❌</span> 단락번호</span>
                        <span class="analysis-item" id="analysisTable"><span class="analysis-icon">❌</span> 표</span>
                    </div>
                </div>
            </div>
            <div class="section">
                <div class="section-title">2단계: 우선권출원 정보 입력</div>
                <div class="priority-input-group">
                    <div class="priority-row">
                        <div class="priority-field">
                            <label>출원년도</label>
                            <input type="text" id="priorityYear" placeholder="2024" maxlength="4">
                        </div>
                        <div class="priority-field">
                            <label>출원월</label>
                            <input type="text" id="priorityMonth" placeholder="01" maxlength="2">
                        </div>
                        <div class="priority-field">
                            <label>출원일</label>
                            <input type="text" id="priorityDay" placeholder="15" maxlength="2">
                        </div>
                    </div>
                    <div class="priority-row">
                        <div class="priority-field wide">
                            <label>출원번호</label>
                            <input type="text" id="priorityNumber" placeholder="10-2024-0012345">
                        </div>
                        <div class="priority-field" style="justify-content: flex-end;">
                            <button class="btn btn-primary" onclick="insertCrossReference()" id="insertCrossRefBtn">📝 Cross-reference 삽입</button>
                        </div>
                    </div>
                </div>
                <div class="note" style="margin-top:15px;">
                    <span class="note-icon">💡</span>
                    <span>모든 정보 입력 후 버튼을 클릭하면 BACKGROUND 단락 앞에 Cross-reference가 삽입됩니다.</span>
                </div>
                <div id="crossRefMessage" class="message hidden"></div>
            </div>
            <div class="section">
                <div class="section-title">3단계: 부제표준화 (선택)</div>
                <div class="subtitle-standard-option">
                    <div class="radio-group">
                        <label class="radio-label">
                            <input type="radio" name="subtitleStandard" value="sdc" checked>
                            <span class="radio-text">SDC표준US</span>
                        </label>
                        <label class="radio-label">
                            <input type="radio" name="subtitleStandard" value="office">
                            <span class="radio-text">사무소표준US</span>
                        </label>
                        <label class="radio-label">
                            <input type="radio" name="subtitleStandard" value="pct">
                            <span class="radio-text">PCT출원용</span>
                        </label>
                    </div>
                    <button class="btn btn-primary" onclick="standardizeSubtitles()" id="standardizeSubtitleBtn">🔄 부제표준화 적용</button>
                </div>
                <div class="note" style="margin-top:15px;">
                    <span class="note-icon">💡</span>
                    <span><strong>SDC표준US:</strong> 국문/사무소부제 → SDC형식 (BACKGROUND, SUMMARY, DETAILED DESCRIPTION 등)<br>
                    <strong>사무소표준US:</strong> 국문부제 → 영문부제 (TITLE OF THE INVENTION, BACKGROUND OF THE INVENTION 등)<br>
                    <strong>PCT출원용:</strong> 국문/영문부제 → PCT형식 (【Technical Field】, 【Background Art】 등). 영문부제 변환 시 **적소이동필요** 표시가 추가됩니다.</span>
                </div>
                <div id="subtitleMessage" class="message hidden"></div>
            </div>
            <div class="section">
                <div class="section-title">4단계: 단락번호 추가/제거 (선택)</div>
                <div class="paragraph-number-option">
                    <button class="btn btn-success" onclick="addParagraphNumbers()" id="addParagraphNumBtn">🔢 단락번호 추가</button>
                    <button class="btn btn-danger" onclick="removeParagraphNumbers()" id="removeParagraphNumBtn">🗑️ 단락번호 제거</button>
                </div>
                <div class="note" style="margin-top:15px;">
                    <span class="note-icon">💡</span>
                    <span>문서의 처음부터 WHAT IS CLAIMED IS: (또는 【CLAIMS】) 이전까지, 마침표로 끝나는 단락에 단락번호가 추가됩니다. 부제목은 제외됩니다.</span>
                </div>
                <div id="paragraphNumMessage" class="message hidden"></div>
            </div>
            <div class="section hidden" id="result1Section">
                <div class="section-title">5단계: 분석 결과</div>
                <div class="stats-row">
                    <div class="stat-card blue"><div class="stat-number" id="subCount1">0</div><div class="stat-label">아래첨자</div></div>
                    <div class="stat-card orange"><div class="stat-number" id="supCount1">0</div><div class="stat-label">위첨자</div></div>
                    <div class="stat-card purple"><div class="stat-number" id="paragraphCount1">0</div><div class="stat-label">단락 개수</div></div>
                    <div class="stat-card teal"><div class="stat-number" id="tableCount1">0</div><div class="stat-label">표 개수</div></div>
                    <div class="stat-card pink"><div class="stat-number" id="claimCount1">0</div><div class="stat-label">청구항 개수</div></div>
                </div>
            </div>
            <div class="section hidden" id="output1Section">
                <div class="section-title">6단계: 변환 결과</div>
                <div class="output-container">
                    <button class="copy-btn" onclick="copyResult1()">📋 복사</button>
                    <div class="output-box" id="output1"></div>
                </div>
                <div class="preview-area" id="preview1" style="margin-top:15px;"></div>
            </div>
        </div>
        
        <!-- 탭2: HTML → DOCX -->
        <div id="tab2" class="tab-content">
            <div class="section">
                <div class="section-title">1단계: 텍스트 입력 또는 파일 업로드</div>
                <div class="btn-group">
                    <button class="example-btn" onclick="loadExample2('chemistry')">🧪 화학식 예시</button>
                    <button class="example-btn" onclick="loadExample2('math')">📐 수학식 예시</button>
                    <button class="example-btn" onclick="loadExample2('mixed')">🔬 복합 예시</button>
                    <button class="example-btn" onclick="loadExample2('table')">📊 표 예시</button>
                </div>
                <div class="unified-input-area">
                    <div class="file-select-row">
                        <input type="file" id="fileInput2" accept=".docx" style="display:none;">
                        <button class="file-select-btn" onclick="document.getElementById('fileInput2').click()">📁 파일 선택</button>
                        <span class="file-name-display" id="fileName2">또는 아래에 .docx 파일을 드래그하세요</span>
                        <button class="btn btn-danger btn-sm" onclick="clearAll2()" style="margin-left:auto;">🗑️ 전체 지우기</button>
                    </div>
                    <textarea id="htmlInput2" placeholder="HTML 태그가 포함된 텍스트를 입력하거나, .docx 파일을 여기에 드래그하여 놓으세요.&#10;&#10;예시:&#10;H<sub>2</sub>O는 물입니다.&#10;x<sup>2</sup> + y<sup>2</sup> = z<sup>2</sup>"></textarea>
                    <span class="drop-hint">📎 .docx 파일 드롭 가능</span>
                </div>
                <div class="note" style="margin-top:10px;">
                    <span class="note-icon">💡</span>
                    <span><code>&lt;sub&gt;</code> → 아래첨자, <code>&lt;sup&gt;</code> → 위첨자, <code>&lt;table&gt;</code> → 워드 표로 변환됩니다.</span>
                </div>
            </div>
            <div class="section">
                <div class="section-title">2단계: 우선권출원 정보 입력</div>
                <div class="priority-input-group">
                    <div class="priority-row">
                        <div class="priority-field">
                            <label>출원년도</label>
                            <input type="text" id="priorityYear2" placeholder="2024" maxlength="4">
                        </div>
                        <div class="priority-field">
                            <label>출원월</label>
                            <input type="text" id="priorityMonth2" placeholder="01" maxlength="2">
                        </div>
                        <div class="priority-field">
                            <label>출원일</label>
                            <input type="text" id="priorityDay2" placeholder="15" maxlength="2">
                        </div>
                    </div>
                    <div class="priority-row">
                        <div class="priority-field wide">
                            <label>출원번호</label>
                            <input type="text" id="priorityNumber2" placeholder="10-2024-0012345">
                        </div>
                        <div class="priority-field" style="justify-content: flex-end;">
                            <button class="btn btn-primary" onclick="insertCrossReference2()" id="insertCrossRefBtn2">📝 Cross-reference 삽입</button>
                        </div>
                    </div>
                </div>
                <div class="note" style="margin-top:15px;">
                    <span class="note-icon">💡</span>
                    <span>모든 정보 입력 후 버튼을 클릭하면 BACKGROUND 단락 앞에 Cross-reference가 삽입됩니다.</span>
                </div>
                <div id="crossRefMessage2" class="message hidden"></div>
            </div>
            <div class="section">
                <div class="section-title">3단계: 부제표준화 (선택)</div>
                <div class="subtitle-standard-option">
                    <div class="radio-group">
                        <label class="radio-label">
                            <input type="radio" name="subtitleStandard2" value="sdc" checked>
                            <span class="radio-text">SDC표준US</span>
                        </label>
                        <label class="radio-label">
                            <input type="radio" name="subtitleStandard2" value="office">
                            <span class="radio-text">사무소표준US</span>
                        </label>
                        <label class="radio-label">
                            <input type="radio" name="subtitleStandard2" value="pct">
                            <span class="radio-text">PCT출원용</span>
                        </label>
                    </div>
                    <button class="btn btn-primary" onclick="standardizeSubtitles2()" id="standardizeSubtitleBtn2">🔄 부제표준화 적용</button>
                </div>
                <div class="note" style="margin-top:15px;">
                    <span class="note-icon">💡</span>
                    <span><strong>SDC표준US:</strong> 국문/사무소부제 → SDC형식 (BACKGROUND, SUMMARY, DETAILED DESCRIPTION 등)<br>
                    <strong>사무소표준US:</strong> 국문부제 → 영문부제 (TITLE OF THE INVENTION, BACKGROUND OF THE INVENTION 등)<br>
                    <strong>PCT출원용:</strong> 국문/영문부제 → PCT형식 (【Technical Field】, 【Background Art】 등). 영문부제 변환 시 **적소이동필요** 표시가 추가됩니다.</span>
                </div>
                <div id="subtitleMessage2" class="message hidden"></div>
            </div>
            <div class="section">
                <div class="section-title">4단계: 단락번호 추가/제거 (선택)</div>
                <div class="paragraph-number-option">
                    <button class="btn btn-success" onclick="addParagraphNumbers2()">🔢 단락번호 추가</button>
                    <button class="btn btn-danger" onclick="removeParagraphNumbers2()">🗑️ 단락번호 제거</button>
                </div>
                <div class="note" style="margin-top:15px;">
                    <span class="note-icon">💡</span>
                    <span>문서의 처음부터 WHAT IS CLAIMED IS: (또는 【CLAIMS】) 이전까지, 마침표로 끝나는 단락에 단락번호가 추가됩니다.</span>
                </div>
                <div id="paragraphNumMessage2" class="message hidden"></div>
            </div>
            <div class="section">
                <div class="section-title">5단계: 미리보기</div>
                <div class="stats-row" style="margin-bottom:15px;">
                    <div class="stat-card blue"><div class="stat-number" id="subCount2">0</div><div class="stat-label">아래첨자</div></div>
                    <div class="stat-card orange"><div class="stat-number" id="supCount2">0</div><div class="stat-label">위첨자</div></div>
                    <div class="stat-card purple"><div class="stat-number" id="paragraphCount2">0</div><div class="stat-label">단락 개수</div></div>
                    <div class="stat-card teal"><div class="stat-number" id="tableCount2">0</div><div class="stat-label">표 개수</div></div>
                </div>
                <div class="btn-group" style="margin-bottom:10px;">
                    <button class="btn btn-primary" onclick="standardizeFormat2()">📐 양식표준화</button>
                </div>
                <div id="formatMessage2" class="message hidden" style="margin-bottom:10px;"></div>
                <div class="preview-area" id="preview2">입력된 텍스트의 미리보기가 여기에 표시됩니다.</div>
            </div>
            <div class="section">
                <div class="section-title">6단계: 파일 생성</div>
                <div class="filename-input">
                    <input type="text" id="outputFileName2" placeholder="파일명">
                    <span>.docx</span>
                </div>
                <button class="btn btn-primary btn-block" onclick="convertToDocx2()">📥 워드 파일 다운로드</button>
                <div id="message2" class="message hidden"></div>
            </div>
        </div>
        
        <!-- 탭3: 한영혼합본 도구 -->
        <div id="tab3" class="tab-content">
            <!-- 서브탭 네비게이션 -->
            <div class="sub-tab-nav">
                <button class="sub-tab-btn active" onclick="switchSubTab3('extract', this)">📤 추출</button>
                <button class="sub-tab-btn" onclick="switchSubTab3('merge', this)">📥 병합</button>
            </div>
            
            <!-- 추출 서브탭 -->
            <div id="subTab3Extract" class="sub-tab-content active">
                <div class="section">
                    <div class="section-title">1단계: 한영혼합본 입력</div>
                    <div class="unified-input-area">
                        <div class="file-select-row">
                            <input type="file" id="fileInput3" accept=".docx" style="display:none;">
                            <button class="file-select-btn" onclick="document.getElementById('fileInput3').click()">📁 파일 선택</button>
                            <span class="file-name-display" id="fileName3">또는 아래에 .docx 파일을 드래그하세요</span>
                            <button class="btn btn-danger btn-sm" onclick="clearAll3()" style="margin-left:auto;">🗑️ 전체 지우기</button>
                        </div>
                        <textarea id="inputText3" placeholder="분석할 텍스트를 입력하거나, .docx 파일을 여기에 드래그하여 놓으세요...&#10;&#10;예시:&#10;TITLE OF THE INVENTION&#10;METHOD AND APPARATUS FOR DATA PROCESSING&#10;BACKGROUND OF THE INVENTION&#10;본 발명은 데이터 처리에 관한 것이다.&#10;The present invention relates to data processing."></textarea>
                        <span class="drop-hint">📎 .docx 파일 드롭 가능</span>
                    </div>
                    <div class="note" style="margin-top:10px;">
                        <span class="note-icon">💡</span>
                        <span>한영혼합본에서 <strong>국문본</strong>과 <strong>영문본</strong>을 각각 추출합니다. 영어 대문자 제목은 부제목으로 분류됩니다.</span>
                    </div>
                </div>
                <div class="btn-group">
                    <button class="btn btn-primary" onclick="analyzeText3()">🔍 영문/국문 추출</button>
                    <button class="btn btn-success" onclick="convertKoreanColor3()">🎨 국문 색변환</button>
                </div>
                <div id="stats3Section" class="section hidden">
                    <div class="section-title">분석 통계 <span style="font-size:12px;color:#666;font-weight:normal;">(클릭하여 필터링)</span></div>
                    <div class="stats-row">
                        <div class="stat-card purple clickable active" data-filter="all" onclick="filterPreview3('all', this)"><div class="stat-number" id="totalCount3">0</div><div class="stat-label">전체 줄</div></div>
                        <div class="stat-card orange clickable" data-filter="subtitle" onclick="filterPreview3('subtitle', this)"><div class="stat-number" id="subtitleCount3">0</div><div class="stat-label">영어부제목</div></div>
                        <div class="stat-card green clickable" data-filter="korean" onclick="filterPreview3('korean', this)"><div class="stat-number" id="koreanCount3">0</div><div class="stat-label">한글단락</div></div>
                        <div class="stat-card blue clickable" data-filter="english" onclick="filterPreview3('english', this)"><div class="stat-number" id="englishCount3">0</div><div class="stat-label">영어단락</div></div>
                    </div>
                </div>
                <div id="preview3Section" class="section hidden">
                    <div class="toggle-section">
                        <div class="section-title" style="margin-bottom:0;">2단계: 분류 미리보기</div>
                        <button class="toggle-btn" onclick="togglePreview3()" id="toggleBtn3">▲ 접기</button>
                    </div>
                    <div id="previewContent3" class="preview-content"><div id="paragraphList3" class="paragraph-list"></div></div>
                </div>
                <div id="result3Section" class="hidden">
                    <div class="section">
                        <div class="section-title">3단계: 영문본</div>
                        <div class="stats-row" style="margin-bottom:15px;">
                            <div class="stat-card blue"><div class="stat-number" id="englishParagraphCount3">0</div><div class="stat-label">단락 개수</div></div>
                            <div class="stat-card purple"><div class="stat-number" id="englishClaimCount3">0</div><div class="stat-label">청구항 개수</div></div>
                            <div class="stat-card blue"><div class="stat-number" id="englishSubCount3">0</div><div class="stat-label">아래첨자</div></div>
                            <div class="stat-card orange"><div class="stat-number" id="englishSupCount3">0</div><div class="stat-label">위첨자</div></div>
                            <div class="stat-card teal"><div class="stat-number" id="englishTableCount3">0</div><div class="stat-label">표 개수</div></div>
                        </div>
                        <div class="btn-group" style="margin-bottom:10px;display:flex;align-items:center;gap:10px;">
                            <button class="btn btn-success" onclick="downloadEngDocx3()">📥 영문본 DOCX 다운로드</button>
                            <button class="btn btn-primary" onclick="standardizeFormatEng3()" style="font-size:0.75em;padding:4px 8px;">📐 양식표준화</button>
                            <button class="btn btn-success" onclick="addParagraphNumbersEng3()" style="font-size:0.75em;padding:4px 8px;">🔢 단락번호 추가</button>
                            <button class="btn btn-danger" onclick="removeParagraphNumbersEng3()" style="font-size:0.75em;padding:4px 8px;">🗑️ 단락번호 제거</button>
                        </div>
                        <div id="engParagraphNumMessage3" class="message hidden" style="margin-bottom:10px;"></div>
                        <div class="dual-panel-container" style="display:flex;gap:15px;">
                            <div class="text-panel" style="flex:1;min-width:0;">
                                <div class="panel-header" style="font-size:0.85em;color:#666;margin-bottom:8px;">📝 원본 텍스트</div>
                                <div class="output-container">
                                    <button class="copy-btn" onclick="copyEnglish3()">복사</button>
                                    <div id="englishResult3" class="output-box" style="max-height:400px;">영문본이 여기에 표시됩니다</div>
                                </div>
                            </div>
                            <div id="englishRenderPanel3" class="render-panel" style="flex:1;min-width:0;display:none;">
                                <div class="panel-header" style="font-size:0.85em;color:#666;margin-bottom:8px;">🖼️ 렌더링 미리보기</div>
                                <div id="englishRender3" class="result-area rendered-preview" style="max-height:400px;overflow-y:auto;background:#fafafa;"></div>
                            </div>
                        </div>
                        <div class="note" style="margin-top:10px;">
                            <span class="note-icon">💡</span>
                            <span>DOCX 다운로드 시 <code>&lt;sub&gt;</code>, <code>&lt;sup&gt;</code>, <code>&lt;table&gt;</code> 태그가 워드 서식으로 변환됩니다.</span>
                        </div>
                    </div>
                    <div class="section">
                        <div class="section-title">4단계: 국문본</div>
                        <div class="stats-row" style="margin-bottom:15px;">
                            <div class="stat-card green"><div class="stat-number" id="koreanParagraphCount3">0</div><div class="stat-label">단락 개수</div></div>
                            <div class="stat-card purple"><div class="stat-number" id="koreanClaimCount3">0</div><div class="stat-label">청구항 개수</div></div>
                            <div class="stat-card blue"><div class="stat-number" id="koreanSubCount3">0</div><div class="stat-label">아래첨자</div></div>
                            <div class="stat-card orange"><div class="stat-number" id="koreanSupCount3">0</div><div class="stat-label">위첨자</div></div>
                            <div class="stat-card teal"><div class="stat-number" id="koreanTableCount3">0</div><div class="stat-label">표 개수</div></div>
                        </div>
                        <div class="btn-group" style="margin-bottom:10px;display:flex;align-items:center;gap:10px;">
                            <button class="btn btn-primary" onclick="downloadKorDocx3()">📥 국문본 DOCX 다운로드</button>
                            <button class="btn btn-primary" onclick="standardizeFormatKor3()" style="font-size:0.75em;padding:4px 8px;">📐 양식표준화</button>
                            <button class="btn btn-success" onclick="addParagraphNumbersKor3()" style="font-size:0.75em;padding:4px 8px;">🔢 단락번호 추가</button>
                            <button class="btn btn-danger" onclick="removeParagraphNumbersKor3()" style="font-size:0.75em;padding:4px 8px;">🗑️ 단락번호 제거</button>
                        </div>
                        <div id="korParagraphNumMessage3" class="message hidden" style="margin-bottom:10px;"></div>
                        <div class="dual-panel-container" style="display:flex;gap:15px;">
                            <div class="text-panel" style="flex:1;min-width:0;">
                                <div class="panel-header" style="font-size:0.85em;color:#666;margin-bottom:8px;">📝 원본 텍스트</div>
                                <div class="output-container">
                                    <button class="copy-btn" onclick="copyKorean3()">복사</button>
                                    <div id="koreanResult3" class="output-box" style="max-height:400px;">국문본이 여기에 표시됩니다</div>
                                </div>
                            </div>
                            <div id="koreanRenderPanel3" class="render-panel" style="flex:1;min-width:0;display:none;">
                                <div class="panel-header" style="font-size:0.85em;color:#666;margin-bottom:8px;">🖼️ 렌더링 미리보기</div>
                                <div id="koreanRender3" class="result-area rendered-preview" style="max-height:400px;overflow-y:auto;background:#fafafa;"></div>
                            </div>
                        </div>
                        <div class="note" style="margin-top:10px;">
                            <span class="note-icon">💡</span>
                            <span>DOCX 다운로드 시 <code>&lt;sub&gt;</code>, <code>&lt;sup&gt;</code>, <code>&lt;table&gt;</code> 태그가 워드 서식으로 변환됩니다.</span>
                        </div>
                    </div>
                </div>
                <!-- 국문 색변환 결과 섹션 -->
                <div id="colorResult3Section" class="hidden">
                    <div class="section">
                        <div class="section-title">국문 색변환 결과</div>
                        <div class="stats-row" style="margin-bottom:15px;">
                            <div class="stat-card purple"><div class="stat-number" id="colorTotalCount3">0</div><div class="stat-label">전체 줄</div></div>
                            <div class="stat-card orange"><div class="stat-number" id="colorSubtitleCount3">0</div><div class="stat-label">영어부제목</div></div>
                            <div class="stat-card green"><div class="stat-number" id="colorKoreanCount3">0</div><div class="stat-label">한글단락 (색변환)</div></div>
                            <div class="stat-card blue"><div class="stat-number" id="colorEnglishCount3">0</div><div class="stat-label">영어단락</div></div>
                        </div>
                        <div class="stats-row" style="margin-bottom:15px;">
                            <div class="stat-card purple"><div class="stat-number" id="colorParagraphCount3">0</div><div class="stat-label">단락 개수</div></div>
                            <div class="stat-card blue"><div class="stat-number" id="colorSubCount3">0</div><div class="stat-label">아래첨자</div></div>
                            <div class="stat-card orange"><div class="stat-number" id="colorSupCount3">0</div><div class="stat-label">위첨자</div></div>
                            <div class="stat-card teal"><div class="stat-number" id="colorTableCount3">0</div><div class="stat-label">표 개수</div></div>
                        </div>
                        <div class="btn-group" style="margin-bottom:10px;display:flex;align-items:center;gap:10px;">
                            <button class="btn btn-primary" onclick="downloadColorDocx3()">📥 한영혼합본 DOCX 다운로드</button>
                            <button class="btn btn-primary" onclick="standardizeFormatColor3()" style="font-size:0.75em;padding:4px 8px;">📐 양식표준화</button>
                            <button class="btn btn-success" onclick="addParagraphNumbersColor3()" style="font-size:0.75em;padding:4px 8px;">🔢 단락번호 추가</button>
                            <button class="btn btn-danger" onclick="removeParagraphNumbersColor3()" style="font-size:0.75em;padding:4px 8px;">🗑️ 단락번호 제거</button>
                        </div>
                        <div id="colorMessage3" class="message hidden" style="margin-bottom:10px;"></div>
                        <div class="preview-area" id="colorPreview3" style="max-height:400px;overflow-y:auto;margin-bottom:15px;">색변환 미리보기가 여기에 표시됩니다.</div>
                        <div class="note" style="margin-top:10px;">
                            <span class="note-icon">💡</span>
                            <span>국문 단락은 <span style="color:#993300;font-weight:bold;">갈색(RGB 153,51,0)</span>으로 표시됩니다. DOCX 다운로드 시 해당 색상이 적용됩니다.</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- 병합 서브탭 -->
            <div id="subTab3Merge" class="sub-tab-content">
                <div class="section">
                    <div class="section-title">1단계: 국문명세서 입력</div>
                    <div class="unified-input-area">
                        <div class="file-select-row">
                            <input type="file" id="fileInputKor3" accept=".docx" style="display:none;">
                            <button class="file-select-btn" onclick="document.getElementById('fileInputKor3').click()">📁 국문 파일 선택</button>
                            <span class="file-name-display" id="fileNameKor3">국문명세서 .docx 파일을 선택하세요</span>
                            <button class="btn btn-danger btn-sm" onclick="clearMerge3()" style="margin-left:auto;">🗑️ 전체 지우기</button>
                        </div>
                        <textarea id="inputTextKor3" placeholder="국문명세서 텍스트를 입력하거나, .docx 파일을 여기에 드래그하여 놓으세요..."></textarea>
                        <span class="drop-hint">📎 .docx 파일 드롭 가능</span>
                    </div>
                </div>
                <div class="section">
                    <div class="section-title">2단계: 영문명세서 입력</div>
                    <div class="unified-input-area">
                        <div class="file-select-row">
                            <input type="file" id="fileInputEng3" accept=".docx" style="display:none;">
                            <button class="file-select-btn" onclick="document.getElementById('fileInputEng3').click()">📁 영문 파일 선택</button>
                            <span class="file-name-display" id="fileNameEng3">영문명세서 .docx 파일을 선택하세요</span>
                        </div>
                        <textarea id="inputTextEng3" placeholder="영문명세서 텍스트를 입력하거나, .docx 파일을 여기에 드래그하여 놓으세요..."></textarea>
                        <span class="drop-hint">📎 .docx 파일 드롭 가능</span>
                    </div>
                </div>
                <div class="note" style="margin-bottom:15px;">
                    <span class="note-icon">💡</span>
                    <span><strong>병합 방식:</strong> <strong style="color:#e74c3c;">사무소표준US 양식</strong>을 기준으로 병합합니다. 국문/영문 부제를 비교하여 불일치 시 경고하며, 일치 시 같은 부제 아래 단락들을 정렬합니다. 영문단락의 부제는 삭제됩니다.</span>
                </div>
                <div class="btn-group">
                    <button class="btn btn-primary" onclick="mergeDocuments3()">🔄 한영혼합본 생성</button>
                </div>
                <div id="merge3StatsSection" class="section hidden">
                    <div class="section-title">병합 통계</div>
                    <div class="stats-row">
                        <div class="stat-card green"><div class="stat-number" id="mergeKorCount">0</div><div class="stat-label">국문 단락</div></div>
                        <div class="stat-card blue"><div class="stat-number" id="mergeEngCount">0</div><div class="stat-label">영문 단락</div></div>
                        <div class="stat-card purple"><div class="stat-number" id="mergeTotalCount">0</div><div class="stat-label">총 단락</div></div>
                    </div>
                </div>
                <div id="merge3ResultSection" class="section hidden">
                    <div class="section-title">3단계: 한영혼합본 결과</div>
                    <div class="btn-group" style="margin-bottom:15px;">
                        <button class="btn btn-success" onclick="copyMergeResult3()">📋 결과 복사</button>
                        <button class="btn btn-primary" onclick="downloadMergeDocx3()">📥 DOCX 다운로드</button>
                    </div>
                    <div class="filename-input" style="margin-bottom:15px;">
                        <input type="text" id="mergeFileName3" placeholder="한영혼합본">
                        <span>.docx</span>
                    </div>
                    <div id="mergeResult3" class="result-area" style="max-height:400px;overflow-y:auto;">한영혼합본이 여기에 표시됩니다</div>
                </div>
                <div id="merge3Message" class="message hidden"></div>
            </div>
        </div>
        
        <!-- 탭4: 문서 비교 -->
        <div id="tab4" class="tab-content">
            <!-- 서브탭 네비게이션 -->
            <div class="sub-tab-nav">
                <button class="sub-tab-btn active" onclick="switchSubTab4('text', this)">📝 텍스트 비교</button>
                <button class="sub-tab-btn" onclick="switchSubTab4('docx', this)">📄 DOCX 비교</button>
            </div>
            
            <!-- 텍스트 비교 서브탭 -->
            <div id="subTab4Text" class="sub-tab-content active">
                <div class="section">
                    <div class="section-title">1단계: 문서 1 입력</div>
                    <div class="unified-input-area">
                        <div class="file-select-row">
                            <input type="file" id="fileInput4a" accept=".docx" style="display:none;">
                            <button class="file-select-btn" onclick="document.getElementById('fileInput4a').click()">📁 파일 선택</button>
                            <span class="file-name-display" id="fileName4a">또는 아래에 .docx 파일을 드래그하세요</span>
                            <button class="btn btn-danger btn-sm" onclick="clearAll4()" style="margin-left:auto;">🗑️ 전체 지우기</button>
                        </div>
                        <textarea id="inputText4a" placeholder="첫 번째 문서의 텍스트를 입력하거나, .docx 파일을 여기에 드래그하여 놓으세요..."></textarea>
                        <span class="drop-hint">📎 .docx 파일 드롭 가능</span>
                    </div>
                </div>
                <div class="section">
                    <div class="section-title">2단계: 문서 2 입력</div>
                    <div class="unified-input-area">
                        <div class="file-select-row">
                            <input type="file" id="fileInput4b" accept=".docx" style="display:none;">
                            <button class="file-select-btn" onclick="document.getElementById('fileInput4b').click()">📁 파일 선택</button>
                            <span class="file-name-display" id="fileName4b">또는 아래에 .docx 파일을 드래그하세요</span>
                        </div>
                        <textarea id="inputText4b" placeholder="두 번째 문서의 텍스트를 입력하거나, .docx 파일을 여기에 드래그하여 놓으세요..."></textarea>
                        <span class="drop-hint">📎 .docx 파일 드롭 가능</span>
                    </div>
                </div>
                <div class="note" style="margin-bottom:15px;">
                    <span class="note-icon">💡</span>
                    <span><strong>비교 조건:</strong> 폰트, 단락 형식 등 서식은 무시하고 <strong>문자 내용만</strong> 비교합니다. 단락번호([0001] 등), 앞뒤 공백, <strong>빈줄</strong>은 자동 제거 후 비교됩니다.</span>
                </div>
                <div class="btn-group">
                    <button class="btn btn-primary" onclick="compareDocuments()">🔍 문서 비교</button>
                </div>
                <div id="compare4Section" class="section hidden">
                    <div class="section-title">3단계: 비교 결과</div>
                    <div class="stats-row">
                        <div class="stat-card blue"><div class="stat-number" id="totalLines4">0</div><div class="stat-label">전체 줄</div></div>
                        <div class="stat-card green"><div class="stat-number" id="sameLines4">0</div><div class="stat-label">동일</div></div>
                        <div class="stat-card orange"><div class="stat-number" id="modifiedLines4">0</div><div class="stat-label">수정됨</div></div>
                        <div class="stat-card pink"><div class="stat-number" id="addedLines4">0</div><div class="stat-label">추가됨</div></div>
                        <div class="stat-card purple"><div class="stat-number" id="deletedLines4">0</div><div class="stat-label">삭제됨</div></div>
                    </div>
                    <div class="compare-legend">
                        <span class="legend-item"><span class="legend-color same"></span> 동일</span>
                        <span class="legend-item"><span class="legend-color modified"></span> 수정됨</span>
                        <span class="legend-item"><span class="legend-color added"></span> 추가됨</span>
                        <span class="legend-item"><span class="legend-color deleted"></span> 삭제됨</span>
                    </div>
                    <div class="compare-container">
                        <div class="compare-panel">
                            <div class="compare-panel-header">문서 1 (원본)</div>
                            <div class="compare-content" id="compareResult4a"></div>
                        </div>
                        <div class="compare-panel">
                            <div class="compare-panel-header">문서 2 (비교)</div>
                            <div class="compare-content" id="compareResult4b"></div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- DOCX 비교 서브탭 -->
            <div id="subTab4Docx" class="sub-tab-content">
                <div class="section">
                    <div class="section-title">1단계: 원본 문서 (DOCX)</div>
                    <div class="unified-input-area">
                        <div class="file-select-row">
                            <input type="file" id="fileInputDocx4a" accept=".docx" style="display:none;">
                            <button class="file-select-btn" onclick="document.getElementById('fileInputDocx4a').click()">📁 원본 파일 선택</button>
                            <span class="file-name-display" id="fileNameDocx4a">원본 .docx 파일을 선택하세요</span>
                            <button class="btn btn-danger btn-sm" onclick="clearDocx4()" style="margin-left:auto;">🗑️ 전체 지우기</button>
                        </div>
                        <textarea id="docxPreview4a" placeholder="원본 문서 내용이 여기에 표시됩니다..." readonly style="cursor:pointer;background:#f9f9f9;min-height:120px;"></textarea>
                        <span class="drop-hint">📎 .docx 파일 드롭 가능</span>
                    </div>
                </div>
                <div class="section">
                    <div class="section-title">2단계: 수정된 문서 (DOCX)</div>
                    <div class="unified-input-area">
                        <div class="file-select-row">
                            <input type="file" id="fileInputDocx4b" accept=".docx" style="display:none;">
                            <button class="file-select-btn" onclick="document.getElementById('fileInputDocx4b').click()">📁 수정 파일 선택</button>
                            <span class="file-name-display" id="fileNameDocx4b">수정된 .docx 파일을 선택하세요</span>
                        </div>
                        <textarea id="docxPreview4b" placeholder="수정된 문서 내용이 여기에 표시됩니다..." readonly style="cursor:pointer;background:#f9f9f9;min-height:120px;"></textarea>
                        <span class="drop-hint">📎 .docx 파일 드롭 가능</span>
                    </div>
                </div>
                <div class="note" style="margin-bottom:15px;">
                    <span class="note-icon">💡</span>
                    <span><strong>DOCX 비교:</strong> 두 문서를 <strong>서식 제외, 텍스트만</strong> 비교합니다. <strong>빈줄은 무시</strong>하고 <strong>단락 내 공백은 유지</strong>합니다. 유사한 단락끼리 매칭하여 <strong>단어 단위</strong>로 변경사항을 표시합니다. MS Word에서 '검토' 탭으로 확인하세요.</span>
                </div>
                <div class="section">
                    <div class="section-title">3단계: 비교 결과 파일 생성</div>
                    <div class="filename-input">
                        <input type="text" id="outputFileNameDocx4" placeholder="비교결과">
                        <span>.docx</span>
                    </div>
                    <div class="btn-group">
                        <button class="btn btn-primary" onclick="compareDocxFiles()">🔍 DOCX 비교 및 다운로드</button>
                    </div>
                    <div id="docxCompareMessage" class="message hidden"></div>
                </div>
                <div id="docxCompareStats" class="section hidden">
                    <div class="section-title">비교 통계</div>
                    <div class="stats-row">
                        <div class="stat-card blue"><div class="stat-number" id="docxTotalPara">0</div><div class="stat-label">전체 단락</div></div>
                        <div class="stat-card green"><div class="stat-number" id="docxSamePara">0</div><div class="stat-label">동일</div></div>
                        <div class="stat-card orange"><div class="stat-number" id="docxModifiedPara">0</div><div class="stat-label">수정됨</div></div>
                        <div class="stat-card pink"><div class="stat-number" id="docxAddedPara">0</div><div class="stat-label">추가됨</div></div>
                        <div class="stat-card purple"><div class="stat-number" id="docxDeletedPara">0</div><div class="stat-label">삭제됨</div></div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- 탭5: Markdown to PDF -->
        <div id="tab5" class="tab-content">
            <div class="section">
                <div class="section-title">Markdown / HTML → PDF 변환</div>
                <div class="md-toolbar" style="margin-bottom:15px;">
                    <div class="font-size-control">
                        <button onclick="changeMdFontSize(-1)" title="작게">−</button>
                        <span id="mdFontSizeDisplay">12px</span>
                        <button onclick="changeMdFontSize(1)" title="크게">+</button>
                    </div>
                    <select id="mdOrientationSelect" onchange="changeMdOrientation()">
                        <option value="portrait">세로 (Portrait)</option>
                        <option value="landscape">가로 (Landscape)</option>
                    </select>
                    <button onclick="clearMdEditor()" style="color:#dc2626;">🗑️ 지우기</button>
                    <button onclick="resetMdExample()">📝 예제 복구</button>
                    <button onclick="downloadMdPDF()" style="background:#1e3a5f;color:#fff;font-weight:600;">📥 PDF 저장</button>
                </div>
                <div class="note" style="margin-bottom:15px;">
                    <span class="note-icon">💡</span>
                    <span>마크다운, HTML, LaTeX 수식($...$, $$...$$)을 모두 지원합니다. 엑셀 표 붙여넣기 가능!</span>
                </div>
            </div>
            <div class="md-editor-container">
                <div class="md-editor-panel editor-panel">
                    <div class="md-panel-header">
                        <span>Editor</span>
                        <span style="color:#3b82f6;font-size:0.8em;">Tip: 엑셀 표 붙여넣기 가능</span>
                    </div>
                    <textarea id="mdInputText" class="md-editor-textarea" placeholder="여기에 마크다운이나 HTML을 입력하세요...">
# 마크다운 & HTML 예제

이 에디터는 **마크다운**과 **HTML**, **LaTeX 수식**을 모두 지원합니다.

## 1. 텍스트 스타일
- **굵게 (Bold)** 또는 __굵게__
- *기울임 (Italic)* 또는 _기울임_
- ~~취소선~~
- <span style="color: #dc2626;">빨간색 텍스트</span>
- <span style="background-color: #fef08a; padding: 0 4px;">형광펜 효과</span>
- <u>밑줄</u>

## 2. 목록
### 순서 없는 목록
- 항목 1
- 항목 2
  - 하위 항목 A
  - 하위 항목 B

### 순서 있는 목록
1. 첫 번째
2. 두 번째

### 체크 리스트
- [x] 완료된 작업
- [ ] 해야 할 작업

## 3. 수식 (LaTeX Math)
인라인 수식: $E = mc^2$, $e^{i\pi} + 1 = 0$

디스플레이 수식:
$$
\sum_{i=1}^{n} i^2 = \frac{n(n+1)(2n+1)}{6}
$$

## 4. 인용
> "지식은 말하기 위한 것이 아니라, 실천하기 위한 것이다."
>
> — 탈무드

## 5. 코드 블록
```python
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)
```

## 6. 표
| ID | 이름 | 직업 | 비고 |
| :---: | :--- | :--- | :--- |
| 1 | 김철수 | 개발자 | 팀장 |
| 2 | 이영희 | 디자이너 | - |
| 3 | 박민수 | 기획자 | - |

## 7. 상세 정보
<details>
<summary>여기를 클릭하여 숨겨진 내용 확인</summary>
<div style="padding-top: 8px;">
이 내용은 접고 펼칠 수 있습니다.
</div>
</details>

---
*우측 상단의 **PDF 저장** 버튼으로 인쇄/저장할 수 있습니다.*
                    </textarea>
                </div>
                <div class="md-editor-panel preview-panel">
                    <div class="md-panel-header">
                        <span>Preview</span>
                        <span id="mdPaperSizeLabel" style="color:#999;font-size:0.8em;">A4 Portrait</span>
                    </div>
                    <div class="md-preview-wrapper">
                        <div id="mdPreviewPaper" class="md-preview-paper">
                            <div id="mdPreviewContent" class="md-preview-content" style="font-size:12px;"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let rawOutput1 = '';
        let fileAnalysisResult = {
            hasCrossRef: false,
            hasScript: false,
            hasParagraphNum: false,
            hasTable: false
        };
        
        function switchMainTab(tabId, btn) {
            document.querySelectorAll('.tab-btn').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            document.getElementById(tabId).classList.add('active');
            btn.classList.add('active');
        }
        
        // 탭1 - 파일 처리 공통 함수
        async function handleFile1(file) {
            if (!file) return;
            if (!file.name.toLowerCase().endsWith('.docx')) {
                alert('❌ .docx 파일만 업로드 가능합니다.');
                return;
            }
            document.getElementById('fileName1').textContent = file.name;
            try {
                const result = await processDocx1(file);
                document.getElementById('textInput1').value = result.text;
                displayResult1(result);
            } catch (error) { alert('오류: ' + error.message); }
        }
        
        // 파일 선택 버튼
        document.getElementById('fileInput1').addEventListener('change', async function(e) {
            const file = e.target.files[0];
            await handleFile1(file);
        });
        
        // 드래그 앤 드롭 (textarea)
        const textInput1 = document.getElementById('textInput1');
        
        textInput1.addEventListener('dragover', function(e) {
            e.preventDefault();
            e.stopPropagation();
            this.classList.add('drag-over');
        });
        
        textInput1.addEventListener('dragleave', function(e) {
            e.preventDefault();
            e.stopPropagation();
            this.classList.remove('drag-over');
        });
        
        textInput1.addEventListener('drop', async function(e) {
            e.preventDefault();
            e.stopPropagation();
            this.classList.remove('drag-over');
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                await handleFile1(files[0]);
            }
        });
        
        // textarea 클릭 시 파일 선택 대화상자 열기
        textInput1.addEventListener('click', function() {
            document.getElementById('fileInput1').click();
        });
        
        async function processDocx1(file) {
            const zip = await JSZip.loadAsync(await file.arrayBuffer());
            const xml = await zip.file('word/document.xml').async('string');
            const doc = new DOMParser().parseFromString(xml, 'application/xml');
            
            // numbering.xml 파싱
            let numberingDefs = {};
            const numberingFile = zip.file('word/numbering.xml');
            if (numberingFile) {
                const numXml = await numberingFile.async('string');
                const numDoc = new DOMParser().parseFromString(numXml, 'application/xml');
                
                // abstractNum 정의 파싱
                const abstractNumDefs = {};
                for (const absNum of numDoc.getElementsByTagName('w:abstractNum')) {
                    const absNumId = absNum.getAttribute('w:abstractNumId');
                    const levels = {};
                    for (const lvl of absNum.getElementsByTagName('w:lvl')) {
                        const ilvl = lvl.getAttribute('w:ilvl');
                        const numFmt = lvl.getElementsByTagName('w:numFmt')[0]?.getAttribute('w:val') || 'decimal';
                        const lvlText = lvl.getElementsByTagName('w:lvlText')[0]?.getAttribute('w:val') || '%1.';
                        const start = parseInt(lvl.getElementsByTagName('w:start')[0]?.getAttribute('w:val') || '1');
                        levels[ilvl] = { numFmt, lvlText, start };
                    }
                    abstractNumDefs[absNumId] = levels;
                }
                
                // num -> abstractNum 매핑
                for (const num of numDoc.getElementsByTagName('w:num')) {
                    const numId = num.getAttribute('w:numId');
                    const absNumIdRef = num.getElementsByTagName('w:abstractNumId')[0]?.getAttribute('w:val');
                    if (absNumIdRef && abstractNumDefs[absNumIdRef]) {
                        numberingDefs[numId] = JSON.parse(JSON.stringify(abstractNumDefs[absNumIdRef]));
                        for (const lvl in numberingDefs[numId]) {
                            numberingDefs[numId][lvl].counter = numberingDefs[numId][lvl].start;
                        }
                    }
                }
            }
            
            // 번호 포맷팅 (단락번호는 4자리 유지)
            function formatNumber(num, fmt) {
                switch (fmt) {
                    case 'decimal': return num.toString().padStart(4, '0');
                    case 'lowerLetter': return String.fromCharCode(96 + ((num - 1) % 26) + 1);
                    case 'upperLetter': return String.fromCharCode(64 + ((num - 1) % 26) + 1);
                    case 'lowerRoman': return toRoman(num).toLowerCase();
                    case 'upperRoman': return toRoman(num);
                    default: return num.toString().padStart(4, '0');
                }
            }
            function toRoman(num) {
                const roman = {M:1000,CM:900,D:500,CD:400,C:100,XC:90,L:50,XL:40,X:10,IX:9,V:5,IV:4,I:1};
                let str = '';
                for (let i of Object.keys(roman)) {
                    let q = Math.floor(num / roman[i]);
                    num -= q * roman[i];
                    str += i.repeat(q);
                }
                return str;
            }
            
            // 단락에서 텍스트 추출 (첨자 포함)
            function extractParagraphText(p, countScripts) {
                let text = '';
                for (const r of p.getElementsByTagName('w:r')) {
                    let t = '';
                    for (const x of r.getElementsByTagName('w:t')) t += x.textContent || '';
                    if (!t) continue;
                    const rPr = r.getElementsByTagName('w:rPr')[0];
                    const va = rPr?.getElementsByTagName('w:vertAlign')[0]?.getAttribute('w:val');
                    if (va === 'subscript') { text += `<sub>${t}</sub>`; if (countScripts) countScripts.sub++; }
                    else if (va === 'superscript') { text += `<sup>${t}</sup>`; if (countScripts) countScripts.sup++; }
                    else text += t;
                }
                return text;
            }
            
            // 표를 HTML로 변환
            function convertTableToHtml(tbl, countScripts) {
                let html = '<table border="1">';
                for (const tr of tbl.getElementsByTagName('w:tr')) {
                    html += '<tr>';
                    for (const tc of tr.getElementsByTagName('w:tc')) {
                        // 셀 병합 처리
                        const tcPr = tc.getElementsByTagName('w:tcPr')[0];
                        const gridSpan = tcPr?.getElementsByTagName('w:gridSpan')[0]?.getAttribute('w:val');
                        const vMerge = tcPr?.getElementsByTagName('w:vMerge')[0];
                        
                        // vMerge가 있고 val이 없으면 병합된 셀 (continue)
                        if (vMerge && !vMerge.getAttribute('w:val')) {
                            continue;
                        }
                        
                        let colspan = gridSpan ? ` colspan="${gridSpan}"` : '';
                        
                        // 셀 내용 추출
                        let cellContent = '';
                        for (const p of tc.getElementsByTagName('w:p')) {
                            const pText = extractParagraphText(p, countScripts);
                            if (cellContent && pText) cellContent += '<br>';
                            cellContent += pText;
                        }
                        html += `<td${colspan}>${cellContent}</td>`;
                    }
                    html += '</tr>';
                }
                html += '</table>';
                return html;
            }
            
            let subCount = 0, supCount = 0;
            const countScripts = { sub: 0, sup: 0 };
            const results = [];
            
            // body 내의 요소들을 순서대로 처리
            const body = doc.getElementsByTagName('w:body')[0];
            if (body) {
                for (const child of body.children) {
                    const tagName = child.tagName;
                    
                    if (tagName === 'w:p') {
                        // 일반 단락 처리
                        let text = '';
                        
                        // 단락 번호 처리
                        const pPr = child.getElementsByTagName('w:pPr')[0];
                        const numPr = pPr?.getElementsByTagName('w:numPr')[0];
                        if (numPr) {
                            const numId = numPr.getElementsByTagName('w:numId')[0]?.getAttribute('w:val');
                            const ilvl = numPr.getElementsByTagName('w:ilvl')[0]?.getAttribute('w:val') || '0';
                            if (numId && numberingDefs[numId] && numberingDefs[numId][ilvl]) {
                                const lvlDef = numberingDefs[numId][ilvl];
                                const formattedNum = lvlDef.counter.toString().padStart(4, '0');
                                text = '[' + formattedNum + '] ';
                                lvlDef.counter++;
                            }
                        }
                        
                        text += extractParagraphText(child, countScripts);
                        if (text.trim()) results.push(text);
                        
                    } else if (tagName === 'w:tbl') {
                        // 표 처리
                        const tableHtml = convertTableToHtml(child, countScripts);
                        results.push(tableHtml);
                    }
                }
            }
            
            return { 
                text: results.join('\n'), 
                subscriptCount: countScripts.sub, 
                superscriptCount: countScripts.sup 
            };
        }
        
        let originalText1 = ''; // 원본 텍스트 저장용
        
        // 파일 분석 결과 표시 함수
        function updateFileAnalysisDisplay() {
            const analysisSection = document.getElementById('fileAnalysis1');
            analysisSection.classList.remove('hidden');
            
            // Cross-reference
            const crossRefEl = document.getElementById('analysisCrossRef');
            if (fileAnalysisResult.hasCrossRef) {
                crossRefEl.innerHTML = '<span class="analysis-icon">✅</span> Cross-reference';
                crossRefEl.className = 'analysis-item exists';
            } else {
                crossRefEl.innerHTML = '<span class="analysis-icon">❌</span> Cross-reference';
                crossRefEl.className = 'analysis-item not-exists';
            }
            
            // 첨자
            const scriptEl = document.getElementById('analysisScript');
            if (fileAnalysisResult.hasScript) {
                scriptEl.innerHTML = '<span class="analysis-icon">✅</span> 첨자';
                scriptEl.className = 'analysis-item exists';
            } else {
                scriptEl.innerHTML = '<span class="analysis-icon">❌</span> 첨자';
                scriptEl.className = 'analysis-item not-exists';
            }
            
            // 단락번호
            const paragraphNumEl = document.getElementById('analysisParagraphNum');
            if (fileAnalysisResult.hasParagraphNum) {
                paragraphNumEl.innerHTML = '<span class="analysis-icon">✅</span> 단락번호';
                paragraphNumEl.className = 'analysis-item exists';
            } else {
                paragraphNumEl.innerHTML = '<span class="analysis-icon">❌</span> 단락번호';
                paragraphNumEl.className = 'analysis-item not-exists';
            }
            
            // 표
            const tableEl = document.getElementById('analysisTable');
            if (fileAnalysisResult.hasTable) {
                tableEl.innerHTML = '<span class="analysis-icon">✅</span> 표';
                tableEl.className = 'analysis-item exists';
            } else {
                tableEl.innerHTML = '<span class="analysis-icon">❌</span> 표';
                tableEl.className = 'analysis-item not-exists';
            }
        }
        
        function displayResult1(r) {
            document.getElementById('subCount1').textContent = r.subscriptCount;
            document.getElementById('supCount1').textContent = r.superscriptCount;
            
            originalText1 = r.text; // 원본 저장
            rawOutput1 = r.text;
            
            // 파일 분석 결과 계산
            fileAnalysisResult.hasCrossRef = /CROSS-REFERENCE/i.test(r.text);
            fileAnalysisResult.hasScript = (r.subscriptCount + r.superscriptCount) > 0;
            fileAnalysisResult.hasParagraphNum = /^\[0\d{3,4}\]\s/m.test(r.text);
            fileAnalysisResult.hasTable = /<table[^>]*>/i.test(r.text);
            
            // 파일 분석 결과 표시
            updateFileAnalysisDisplay();
            
            // 청구항 개수 계산 - 【청구항 XX】 패턴에서 가장 큰 숫자 찾기
            let claimCount = 0;
            const claimMatches = r.text.match(/【청구항\s*(\d+)】/g);
            if (claimMatches) {
                claimMatches.forEach(match => {
                    const num = parseInt(match.match(/\d+/)[0]);
                    if (num > claimCount) claimCount = num;
                });
            }
            document.getElementById('claimCount1').textContent = claimCount;
            
            // 표 개수 계산
            const tableMatches = r.text.match(/<table[^>]*>/gi);
            const tableCount = tableMatches ? tableMatches.length : 0;
            document.getElementById('tableCount1').textContent = tableCount;
            
            // 출력 박스 - 표 태그 하이라이트 처리
            let outputHtml = rawOutput1
                .replace(/</g,'&lt;').replace(/>/g,'&gt;')
                .replace(/&lt;sub&gt;/g,'<span class="sub-tag">&lt;sub&gt;</span>')
                .replace(/&lt;\/sub&gt;/g,'<span class="sub-tag">&lt;/sub&gt;</span>')
                .replace(/&lt;sup&gt;/g,'<span class="sup-tag">&lt;sup&gt;</span>')
                .replace(/&lt;\/sup&gt;/g,'<span class="sup-tag">&lt;/sup&gt;</span>')
                .replace(/&lt;table[^&]*&gt;/g,'<span class="table-tag">&lt;table&gt;</span>')
                .replace(/&lt;\/table&gt;/g,'<span class="table-tag">&lt;/table&gt;</span>')
                .replace(/&lt;tr&gt;/g,'<span class="table-tag">&lt;tr&gt;</span>')
                .replace(/&lt;\/tr&gt;/g,'<span class="table-tag">&lt;/tr&gt;</span>')
                .replace(/&lt;td([^&]*)&gt;/g,'<span class="table-tag">&lt;td$1&gt;</span>')
                .replace(/&lt;\/td&gt;/g,'<span class="table-tag">&lt;/td&gt;</span>')
                .replace(/&lt;br&gt;/g,'<span class="table-tag">&lt;br&gt;</span>')
                .replace(/__([^_]+)__/g,'<span style="color:#e74c3c;font-weight:600;">$1</span>');
            document.getElementById('output1').innerHTML = outputHtml;
            
            // 미리보기 - 표는 실제 HTML로 렌더링
            let previewHtml = rawOutput1;
            // 표가 아닌 줄바꿈만 <br>로 변환
            let inTable = false;
            const lines = previewHtml.split('\n');
            let previewLines = [];
            for (let line of lines) {
                if (line.trim().startsWith('<table')) inTable = true;
                if (inTable) {
                    previewLines.push(line);
                } else {
                    previewLines.push(line + '<br>');
                }
                if (line.trim().endsWith('</table>')) inTable = false;
            }
            previewHtml = previewLines.join('').replace(/__([^_]+)__/g,'<strong>$1</strong>');
            document.getElementById('preview1').innerHTML = previewHtml;
            
            document.getElementById('result1Section').classList.remove('hidden');
            document.getElementById('output1Section').classList.remove('hidden');
        }
        
        function insertCrossReference() {
            const msg = document.getElementById('crossRefMessage');
            msg.classList.add('hidden');
            
            const textInput1 = document.getElementById('textInput1');
            const currentText = textInput1.value;
            
            // 텍스트 입력 확인
            if (!currentText.trim()) {
                msg.textContent = '❌ 먼저 텍스트를 입력하거나 워드 파일을 업로드해주세요.';
                msg.className = 'message error';
                return;
            }
            
            // 이미 Cross-reference가 존재하는지 확인
            if (/CROSS-REFERENCE/i.test(currentText)) {
                msg.textContent = '⚠️ 이미 Cross-reference가 존재합니다.';
                msg.className = 'message error';
                return;
            }
            
            // 우선권출원 정보 확인
            const year = document.getElementById('priorityYear').value.trim();
            const month = document.getElementById('priorityMonth').value.trim();
            const day = document.getElementById('priorityDay').value.trim();
            const appNum = document.getElementById('priorityNumber').value.trim();
            
            if (!year || !month || !day || !appNum) {
                msg.textContent = '❌ 모든 우선권출원 정보를 입력해주세요.';
                msg.className = 'message error';
                return;
            }
            
            // Cross-reference 텍스트 생성
            const crossRef = `CROSS-REFERENCE TO RELATED APPLICATIONS\n본 출원은 ${year}년 ${month}월 ${day}일 출원된 대한민국 특허출원 제${appNum}호에 기초한 것으로서, 그 전체 내용이 참조로 여기에 포함된다.`;
            
            // BACKGROUND로 시작하는 단락 찾기
            const lines = currentText.split('\n');
            let insertIndex = -1;
            for (let i = 0; i < lines.length; i++) {
                if (lines[i].trim().toUpperCase().startsWith('BACKGROUND')) {
                    insertIndex = i;
                    break;
                }
            }
            
            if (insertIndex < 0) {
                msg.textContent = '❌ BACKGROUND 단락을 찾을 수 없습니다.';
                msg.className = 'message error';
                return;
            }
            
            // 삽입 (빈줄 없이)
            lines.splice(insertIndex, 0, crossRef);
            rawOutput1 = lines.join('\n');
            document.getElementById('textInput1').value = rawOutput1;
            
            // 분석 결과 업데이트
            fileAnalysisResult.hasCrossRef = true;
            updateFileAnalysisDisplay();
            
            // 화면 업데이트
            document.getElementById('output1').innerHTML = rawOutput1.replace(/</g,'&lt;').replace(/>/g,'&gt;')
                .replace(/&lt;sub&gt;/g,'<span class="sub-tag">&lt;sub&gt;</span>')
                .replace(/&lt;\/sub&gt;/g,'<span class="sub-tag">&lt;/sub&gt;</span>')
                .replace(/&lt;sup&gt;/g,'<span class="sup-tag">&lt;sup&gt;</span>')
                .replace(/&lt;\/sup&gt;/g,'<span class="sup-tag">&lt;/sup&gt;</span>')
                .replace(/__([^_]+)__/g,'<span style="color:#e74c3c;font-weight:600;">$1</span>');
            document.getElementById('preview1').innerHTML = rawOutput1.replace(/\n/g,'<br>').replace(/__([^_]+)__/g,'<strong>$1</strong>');
            
            msg.textContent = '✅ Cross-reference가 삽입되었습니다!';
            msg.className = 'message success';
            setTimeout(() => msg.classList.add('hidden'), 3000);
        }
        
        // 부제표준화 함수
        function standardizeSubtitles() {
            const msg = document.getElementById('subtitleMessage');
            msg.classList.add('hidden');
            
            const textInput1El = document.getElementById('textInput1');
            const currentText = textInput1El.value;
            
            if (!currentText.trim()) {
                msg.textContent = '❌ 먼저 텍스트를 입력하거나 워드 파일을 업로드해주세요.';
                msg.className = 'message error';
                return;
            }
            
            // 선택된 표준 확인
            const selectedStandard = document.querySelector('input[name="subtitleStandard"]:checked').value;
            
            let result = currentText;
            let convertedCount = 0;
            
            // 변환 규칙 정의
            const officeUSRules = [
                // 국문부제 -> 영문부제 (사무소 표준 US)
                { from: '【발명의 설명】', to: '', delete: true },
                { from: '【발명의 명칭】', to: 'TITLE OF THE INVENTION' },
                { from: '【기술분야】', to: 'BACKGROUND OF THE INVENTION\n(a) Field of the Invention' },
                { from: '【발명의 배경이 되는 기술】', to: '(b) Description of the Related Art' },
                { from: '【배경기술】', to: '(b) Description of the Related Art' },
                { from: '【발명의 내용】', to: 'SUMMARY OF THE INVENTION' },
                { from: '【해결하고자 하는 과제】', to: '', delete: true },
                { from: '【기술적 과제】', to: '', delete: true },
                { from: '【과제의 해결 수단】', to: '', delete: true },
                { from: '【기술적 해결방법】', to: '', delete: true },
                { from: '【발명의 효과】', to: '', delete: true },
                { from: '【도면의 간단한 설명】', to: 'BRIEF DESCRIPTION OF THE DRAWINGS' },
                { from: '【발명을 실시하기 위한 구체적인 내용】', to: 'DETAILED DESCRIPTION OF THE EMBODIMENTS' },
                { from: '【발명의 실시를 위한 형태】', to: 'DETAILED DESCRIPTION OF THE EMBODIMENTS' },
                { from: '【부호의 설명】', to: 'Description of Symbols' },
                { from: '【청구범위】', to: 'WHAT IS CLAIMED IS:' },
                { from: '【청구의 범위】', to: 'WHAT IS CLAIMED IS:' },
                { from: '【요약서】', to: 'ABSTRACT OF DISCLOSURE' },
                { from: '【요약】', to: '', delete: true },
                { from: '【대표도】', to: 'Representative Drawing:' }
            ];
            
            const sdcUSRules = [
                // 국문부제 -> SDC표준 US
                { from: '【발명의 설명】', to: '', delete: true },
                { from: '【발명의 명칭】', to: '', delete: true },
                { from: '【기술분야】', to: 'BACKGROUND\n1. Field' },
                { from: '【발명의 배경이 되는 기술】', to: '2. Description of the Related Art' },
                { from: '【배경기술】', to: '2. Description of the Related Art' },
                { from: '【발명의 내용】', to: 'SUMMARY' },
                { from: '【해결하고자 하는 과제】', to: '', delete: true },
                { from: '【기술적 과제】', to: '', delete: true },
                { from: '【과제의 해결 수단】', to: '', delete: true },
                { from: '【기술적 해결방법】', to: '', delete: true },
                { from: '【발명의 효과】', to: '', delete: true },
                { from: '【도면의 간단한 설명】', to: 'BRIEF DESCRIPTION OF THE DRAWINGS' },
                { from: '【발명을 실시하기 위한 구체적인 내용】', to: 'DETAILED DESCRIPTION' },
                { from: '【발명의 실시를 위한 형태】', to: 'DETAILED DESCRIPTION' },
                { from: '【부호의 설명】', to: 'Description of Symbols' },
                { from: '【청구범위】', to: 'WHAT IS CLAIMED IS:' },
                { from: '【청구의 범위】', to: 'WHAT IS CLAIMED IS:' },
                { from: '【요약서】', to: 'ABSTRACT' },
                { from: '【요약】', to: '', delete: true },
                { from: '【대표도】', to: 'Representative Drawing:' },
                // 사무소표준 -> SDC표준 변환
                { from: 'TITLE OF THE INVENTION', to: '', delete: true },
                { from: 'BACKGROUND OF THE INVENTION', to: 'BACKGROUND' },
                { from: '(a) Field of the Invention', to: '1. Field' },
                { from: '(b) Description of the Related Art', to: '2. Description of the Related Art' },
                { from: 'SUMMARY OF THE INVENTION', to: 'SUMMARY' },
                { from: 'DETAILED DESCRIPTION OF THE EMBODIMENTS', to: 'DETAILED DESCRIPTION' },
                { from: 'DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS', to: 'DETAILED DESCRIPTION' },
                { from: 'ABSTRACT OF DISCLOSURE', to: 'ABSTRACT' }
            ];
            
            const pctRules = [
                // 국문부제 -> PCT출원용
                { from: '【발명의 설명】', to: '【DESCRIPTION】' },
                { from: '【발명의 명칭】', to: '【Invention Title】' },
                { from: '【기술분야】', to: '【Technical Field】' },
                { from: '【배경기술】', to: '【Background Art】' },
                { from: '【발명의 배경이 되는 기술】', to: '【Background Art】' },
                { from: '【발명의 내용】', to: '【Disclosure】' },
                { from: '【기술적 과제】', to: '【Technical Problem】' },
                { from: '【해결하고자 하는 과제】', to: '【Technical Problem】' },
                { from: '【기술적 해결방법】', to: '【Technical Solution】' },
                { from: '【과제의 해결 수단】', to: '【Technical Solution】' },
                { from: '【발명의 효과】', to: '【Advantageous Effects】' },
                { from: '【도면의 간단한 설명】', to: '【Description of Drawings】' },
                { from: '【발명의 실시를 위한 최선의 형태】', to: '【Best Mode】' },
                { from: '【발명의 실시를 위한 형태】', to: '【Mode for Invention】' },
                { from: '【발명을 실시하기 위한 구체적인 내용】', to: '【Mode for Invention】' },
                { from: '【산업상 이용가능성】', to: '【Industrial Applicability】' },
                { from: '【서열목록】', to: '【Sequence List Text】' },
                { from: '【부호의 설명】', to: '【Description of Symbols】' },
                { from: '【청구의 범위】', to: '【CLAIMS】' },
                { from: '【청구범위】', to: '【CLAIMS】' },
                { from: '【요약서】', to: '【ABSTRACT】' },
                { from: '【요약】', to: '【ABSTRACT】' },
                { from: '【도면】', to: '【DRAWINGS】' },
                { from: '【대표도】', to: '【Representative Drawing】' },
                // 영문부제(사무소표준US) -> PCT출원용
                { from: 'TITLE OF THE INVENTION', to: '【Invention Title】' },
                { from: 'BACKGROUND OF THE INVENTION', to: '', delete: true },
                { from: '(a) Field of the Invention', to: '【Technical Field】' },
                { from: '(b) Description of the Related Art', to: '【Background Art】' },
                { from: 'SUMMARY OF THE INVENTION', to: '【Disclosure】\n【Technical Problem】\n【Technical Solution】**적소이동필요**\n【Advantageous Effects】**적소이동필요**' },
                { from: 'BRIEF DESCRIPTION OF THE DRAWINGS', to: '【Description of Drawings】' },
                { from: 'DETAILED DESCRIPTION OF THE EMBODIMENTS', to: '【Mode for Invention】' },
                { from: 'DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS', to: '【Mode for Invention】' },
                { from: 'WHAT IS CLAIMED IS:', to: '【CLAIMS】' },
                { from: 'ABSTRACT OF DISCLOSURE', to: '【ABSTRACT】' },
                { from: 'Description of Symbols', to: '【Description of Symbols】' },
                // SDC표준US -> PCT출원용
                { from: 'BACKGROUND', to: '', delete: true },
                { from: '1. Field', to: '【Technical Field】' },
                { from: '2. Description of the Related Art', to: '【Background Art】' },
                { from: 'SUMMARY', to: '【Disclosure】\n【Technical Problem】\n【Technical Solution】**적소이동필요**\n【Advantageous Effects】**적소이동필요**' },
                { from: 'DETAILED DESCRIPTION', to: '【Mode for Invention】' },
                { from: 'ABSTRACT', to: '【ABSTRACT】' }
            ];
            
            // 선택된 표준에 따라 규칙 선택
            let rules = [];
            let standardName = '';
            
            if (selectedStandard === 'office') {
                rules = officeUSRules;
                standardName = '사무소표준US';
            } else if (selectedStandard === 'sdc') {
                rules = sdcUSRules;
                standardName = 'SDC표준US';
            } else if (selectedStandard === 'pct') {
                rules = pctRules;
                standardName = 'PCT출원용';
            }
            
            // 라인 단위로 변환 적용
            const lines = result.split('\n');
            const resultLines = [];
            let figureCount = 0; // 도면 개수 추적
            
            for (let i = 0; i < lines.length; i++) {
                let line = lines[i];
                let trimmedLine = line.trim();
                let matched = false;
                
                for (const rule of rules) {
                    if (trimmedLine === rule.from) {
                        matched = true;
                        convertedCount++;
                        if (rule.delete) {
                            // 삭제 (라인 건너뜀)
                        } else {
                            // 변환 적용 (여러 줄일 수 있음)
                            const newLines = rule.to.split('\n');
                            newLines.forEach(nl => resultLines.push(nl));
                        }
                        break;
                    }
                }
                
                // PCT 출원용 특수 패턴 처리
                if (!matched && selectedStandard === 'pct') {
                    // 【청구항 X】 -> 【Claim X】 패턴 처리
                    const claimMatch = trimmedLine.match(/^【청구항\s*(\d+)】$/);
                    if (claimMatch) {
                        resultLines.push(`【Claim ${claimMatch[1]}】`);
                        matched = true;
                        convertedCount++;
                    }
                    
                    // 【도 X】 -> 【Figure X】 패턴 처리
                    const figMatch = trimmedLine.match(/^【도\s*(\d+)】$/);
                    if (figMatch) {
                        resultLines.push(`【Figure ${figMatch[1]}】`);
                        matched = true;
                        convertedCount++;
                        figureCount = Math.max(figureCount, parseInt(figMatch[1]));
                    }
                    
                    // 청구항 번호 패턴: "X." 또는 "X. " (줄의 시작) -> 【Claim X】
                    const claimNumMatch = trimmedLine.match(/^(\d+)\.\s+(.*)$/);
                    if (claimNumMatch) {
                        resultLines.push(`【Claim ${claimNumMatch[1]}】`);
                        resultLines.push(claimNumMatch[2]); // 청구항 내용
                        matched = true;
                        convertedCount++;
                    }
                    
                    // FIG. X 또는 Fig. X 패턴 카운트 (도면 개수 파악용)
                    const figRefMatch = trimmedLine.match(/(?:FIG\.|Fig\.)\s*(\d+)/gi);
                    if (figRefMatch) {
                        figRefMatch.forEach(m => {
                            const num = parseInt(m.match(/\d+/)[0]);
                            figureCount = Math.max(figureCount, num);
                        });
                    }
                }
                
                if (!matched) {
                    resultLines.push(line);
                }
            }
            
            // PCT 출원용: 문서 맨 앞에 【DESCRIPTION】 추가 (없는 경우)
            if (selectedStandard === 'pct') {
                const hasDescription = resultLines.some(line => 
                    line.trim() === '【DESCRIPTION】' || line.trim() === '【발명의 설명】'
                );
                if (!hasDescription) {
                    resultLines.unshift('【DESCRIPTION】');
                    convertedCount++;
                }
                
                // 문서 마지막에 【DRAWINGS】와 【Figure X】 추가 (도면 참조가 있는 경우)
                if (figureCount > 0) {
                    const hasDrawings = resultLines.some(line => 
                        line.trim() === '【DRAWINGS】' || line.trim() === '【도면】'
                    );
                    if (!hasDrawings) {
                        resultLines.push('【DRAWINGS】');
                        for (let f = 1; f <= figureCount; f++) {
                            resultLines.push(`【Figure ${f}】`);
                        }
                        convertedCount++;
                    }
                }
            }
            
            result = resultLines.join('\n');
            
            if (convertedCount === 0) {
                msg.textContent = '⚠️ 변환할 부제를 찾지 못했습니다. 문서에 국문 또는 영문 부제가 있는지 확인해주세요.';
                msg.className = 'message error';
                return;
            }
            
            // 결과 적용
            rawOutput1 = result;
            textInput1El.value = result;
            
            // 화면 업데이트
            document.getElementById('output1').innerHTML = result.replace(/</g,'&lt;').replace(/>/g,'&gt;')
                .replace(/&lt;sub&gt;/g,'<span class="sub-tag">&lt;sub&gt;</span>')
                .replace(/&lt;\/sub&gt;/g,'<span class="sub-tag">&lt;/sub&gt;</span>')
                .replace(/&lt;sup&gt;/g,'<span class="sup-tag">&lt;sup&gt;</span>')
                .replace(/&lt;\/sup&gt;/g,'<span class="sup-tag">&lt;/sup&gt;</span>');
            document.getElementById('preview1').innerHTML = result.replace(/\n/g,'<br>');
            
            msg.textContent = `✅ 부제표준화 완료! (${standardName} 형식, ${convertedCount}개 부제 변환됨)`;
            msg.className = 'message success';
            setTimeout(() => msg.classList.add('hidden'), 5000);
        }
        
        // 모달 관련 함수
        function showCrossRefWarningModal() {
            document.getElementById('crossRefWarningModal').classList.add('active');
        }
        
        function closeModal() {
            document.getElementById('crossRefWarningModal').classList.remove('active');
        }
        
        function goToCrossRefInsert() {
            closeModal();
            // 2단계(Cross-reference 삽입) 영역으로 스크롤 및 포커스
            const prioritySection = document.getElementById('priorityYear');
            if (prioritySection) {
                prioritySection.scrollIntoView({ behavior: 'smooth', block: 'center' });
                setTimeout(() => prioritySection.focus(), 500);
            }
        }
        
        function proceedWithoutCrossRef() {
            closeModal();
            // Cross-reference 없이 단락번호 추가 진행
            executeAddParagraphNumbers();
        }
        
        function addParagraphNumbers() {
            const msg = document.getElementById('paragraphNumMessage');
            msg.classList.add('hidden');
            
            const textInput1El = document.getElementById('textInput1');
            const currentText = textInput1El.value;
            
            // 텍스트 입력 확인
            if (!currentText.trim()) {
                msg.textContent = '❌ 먼저 텍스트를 입력하거나 워드 파일을 업로드해주세요.';
                msg.className = 'message error';
                return;
            }
            
            // 이미 단락번호가 존재하는지 확인 (0으로 시작하는 4~5자리, 뒤에 공백)
            if (/^\[0\d{3,4}\]\s/m.test(currentText)) {
                msg.textContent = '⚠️ 이미 단락번호가 존재합니다. 단락번호를 제거한 후 다시 시도해주세요.';
                msg.className = 'message error';
                return;
            }
            
            // 바로 단락번호 추가 진행
            executeAddParagraphNumbers();
        }
        
        function executeAddParagraphNumbers() {
            const msg = document.getElementById('paragraphNumMessage');
            const textInput1El = document.getElementById('textInput1');
            const currentText = textInput1El.value;
            
            // 부제목 판별 함수
            function isSubtitle(line) {
                const trimmed = line.trim();
                if (!trimmed) return false;
                
                // 정확히 일치하는 부제목들
                const exactSubtitles = [
                    'CROSS-REFERENCE TO RELATED APPLICATIONS',
                    'BACKGROUND OF THE INVENTION',
                    'BACKGROUND',
                    'SUMMARY OF THE INVENTION',
                    'SUMMARY',
                    'BRIEF DESCRIPTION OF THE DRAWINGS',
                    'DETAILED DESCRIPTION OF THE EMBODIMENTS',
                    'DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS',
                    'DETAILED DESCRIPTION',
                    'DESCRIPTION OF SYMBOLS',
                    'Description of Symbols',
                    '<Description of Symbols>',
                    '<DESCRIPTION OF SYMBOLS>',
                    'WHAT IS CLAIMED IS:',
                    'WHAT IS CLAIMED IS',
                    'TITLE OF THE INVENTION',
                    'ABSTRACT OF DISCLOSURE',
                    'ABSTRACT'
                ];
                if (exactSubtitles.some(s => trimmed.toUpperCase() === s.toUpperCase() || trimmed === s)) return true;
                
                // 【】로 묶인 부제 패턴 (PCT형식 포함)
                if (/^【[^】]+】$/.test(trimmed)) return true;
                
                // <Description of Symbols> 형식 체크
                if (/^<?\s*Description\s+of\s+Symbols\s*>?$/i.test(trimmed)) return true;
                
                // 표 타이틀 패턴: 【표 1】, [표 1], 【Table 1】, [Table 1] 등
                if (/^[【\[]표\s*\d+[】\]]$/i.test(trimmed)) return true;
                if (/^[【\[]Table\s*\d+[】\]]$/i.test(trimmed)) return true;
                
                // 수학식/화학식/반응식/분자식 등 타이틀 패턴
                if (/^[【\[](수학식|화학식|반응식|분자식)\s*\d*[】\]]$/.test(trimmed)) return true;
                if (/^[【\[](Mathematical\s*Formula|Chemical\s*Formula|Reaction\s*Formula|Molecular\s*Formula)\s*\d*[】\]]$/i.test(trimmed)) return true;
                
                // 실시예, 실험예 등을 포함하면서 마침표 없이 끝나는 경우
                if (/^(실시예|실험예|비교예|참고예|제조예|Example|Comparative\s*Example|Reference\s*Example)/i.test(trimmed) && !trimmed.includes('.')) return true;
                
                // (a), (b), (c) 등으로 시작하는 부제목
                if (/^\([a-zA-Z]\)\s+/.test(trimmed)) return true;
                
                // 1., 2., 3. 등 숫자로 시작하는 부제목 (숫자. 텍스트 형식)
                if (/^\d+\.\s+[A-Z]/.test(trimmed)) return true;
                
                // 전체가 대문자인 짧은 제목 (단어 수 6개 이하)
                const words = trimmed.split(/\s+/);
                if (words.length <= 6 && /^[A-Z\s]+$/.test(trimmed) && trimmed.length > 3) return true;
                
                return false;
            }
            
            // 청구항 시작 판별 함수 (종료 지점)
            function isClaimsStart(line) {
                const trimmed = line.trim();
                const upper = trimmed.toUpperCase();
                // WHAT IS CLAIMED IS: 또는 【CLAIMS】
                if (upper === 'WHAT IS CLAIMED IS:' || upper === 'WHAT IS CLAIMED IS') return true;
                if (trimmed === '【CLAIMS】' || trimmed === '【청구의 범위】' || trimmed === '【청구범위】') return true;
                return false;
            }
            
            const lines = currentText.split('\n');
            
            // 종료 지점 찾기 (WHAT IS CLAIMED IS: 또는 【CLAIMS】)
            let stopIndex = -1;
            for (let i = 0; i < lines.length; i++) {
                if (isClaimsStart(lines[i])) {
                    stopIndex = i;
                    break;
                }
            }
            
            let counter = 1;
            let insideTable = false;
            const resultLines = [];
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const trimmed = line.trim();
                
                // 표 시작/종료 감지
                if (trimmed.startsWith('<table')) {
                    insideTable = true;
                }
                if (trimmed.endsWith('</table>')) {
                    insideTable = false;
                    resultLines.push(line);
                    continue;
                }
                
                // 종료 지점 도달 시 번호 추가 중단
                let stopNumbering = (stopIndex >= 0 && i >= stopIndex);
                
                // 번호 붙이기 로직 (표 내용에는 번호 부여하지 않음, 마침표로 끝나는 단락만)
                if (!stopNumbering && trimmed && !isSubtitle(line) && !insideTable && /[.。]["']?$/.test(trimmed)) {
                    // 이미 단락번호가 있는지 확인 (4~5자리)
                    if (!/^\[\d{4,5}\]\s/.test(trimmed)) {
                        const paraNum = '[' + counter.toString().padStart(4, '0') + '] ';
                        resultLines.push(paraNum + line);
                        counter++;
                    } else {
                        resultLines.push(line);
                    }
                } else {
                    resultLines.push(line);
                }
            }
            
            rawOutput1 = resultLines.join('\n');
            document.getElementById('textInput1').value = rawOutput1;
            
            // 분석 결과 업데이트
            fileAnalysisResult.hasParagraphNum = true;
            updateFileAnalysisDisplay();
            
            // 화면 업데이트
            document.getElementById('output1').innerHTML = rawOutput1.replace(/</g,'&lt;').replace(/>/g,'&gt;')
                .replace(/&lt;sub&gt;/g,'<span class="sub-tag">&lt;sub&gt;</span>')
                .replace(/&lt;\/sub&gt;/g,'<span class="sub-tag">&lt;/sub&gt;</span>')
                .replace(/&lt;sup&gt;/g,'<span class="sup-tag">&lt;sup&gt;</span>')
                .replace(/&lt;\/sup&gt;/g,'<span class="sup-tag">&lt;/sup&gt;</span>')
                .replace(/\[(\d{4,5})\]/g,'<span style="color:#27ae60;font-weight:600;">[$1]</span>');
            document.getElementById('preview1').innerHTML = rawOutput1.replace(/\n/g,'<br>');
            
            msg.textContent = `✅ 단락번호가 추가되었습니다! (총 ${counter - 1}개 단락)`;
            msg.className = 'message success';
            
            // 단락 개수 업데이트
            document.getElementById('paragraphCount1').textContent = counter - 1;
            
            setTimeout(() => msg.classList.add('hidden'), 3000);
        }
        
        function removeParagraphNumbers() {
            const msg = document.getElementById('paragraphNumMessage');
            msg.classList.add('hidden');
            
            const textInput1El = document.getElementById('textInput1');
            const currentText = textInput1El.value;
            
            // 텍스트 입력 확인
            if (!currentText.trim()) {
                msg.textContent = '❌ 먼저 텍스트를 입력하거나 워드 파일을 업로드해주세요.';
                msg.className = 'message error';
                return;
            }
            
            // 단락번호 제거 (임의 자릿수, 공백 유무 상관없이)
            const lines = currentText.split('\n');
            let removedCount = 0;
            const resultLines = lines.map(line => {
                if (/^\[\d+\]/.test(line)) {
                    removedCount++;
                    return line.replace(/^\[\d+\]\s?/, '');
                }
                return line;
            });
            
            if (removedCount === 0) {
                msg.textContent = '❌ 제거할 단락번호가 없습니다.';
                msg.className = 'message error';
                return;
            }
            
            rawOutput1 = resultLines.join('\n');
            document.getElementById('textInput1').value = rawOutput1;
            
            // 분석 결과 업데이트
            fileAnalysisResult.hasParagraphNum = false;
            updateFileAnalysisDisplay();
            
            // 화면 업데이트
            document.getElementById('output1').innerHTML = rawOutput1.replace(/</g,'&lt;').replace(/>/g,'&gt;')
                .replace(/&lt;sub&gt;/g,'<span class="sub-tag">&lt;sub&gt;</span>')
                .replace(/&lt;\/sub&gt;/g,'<span class="sub-tag">&lt;/sub&gt;</span>')
                .replace(/&lt;sup&gt;/g,'<span class="sup-tag">&lt;sup&gt;</span>')
                .replace(/&lt;\/sup&gt;/g,'<span class="sup-tag">&lt;/sup&gt;</span>');
            document.getElementById('preview1').innerHTML = rawOutput1.replace(/\n/g,'<br>');
            
            // 단락 개수 초기화
            document.getElementById('paragraphCount1').textContent = 0;
            
            msg.textContent = `✅ 단락번호가 제거되었습니다! (${removedCount}개 제거)`;
            msg.className = 'message success';
            setTimeout(() => msg.classList.add('hidden'), 3000);
        }
        
        function copyResult1() {
            const text = document.getElementById('textInput1').value;
            navigator.clipboard.writeText(text).then(() => {
                const b = document.querySelector('#output1Section .copy-btn');
                b.textContent = '복사됨!'; setTimeout(() => b.textContent = '📋 복사', 2000);
            });
        }
        
        // DOCX 생성 공통 함수 (후처리 탭에서 사용) - font size 12pt 적용
        async function generateDocxCommon(text, filename, msgElement) {
            let bodyContent = '';
            let insideTable = false;
            let tableBuffer = '';
            
            const lines = text.split('\n');
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const trimmed = line.trim();
                
                // 페이지 나누기 마커 처리
                if (trimmed === '<pagebreak/>') {
                    bodyContent += '<w:p><w:r><w:br w:type="page"/></w:r></w:p>';
                    continue;
                }
                
                // 표 시작 감지
                if (trimmed.startsWith('<table')) {
                    // 한 줄에 표 전체가 있는 경우
                    if (trimmed.includes('</table>')) {
                        bodyContent += convertHtmlTableToOoxml(line);
                        continue;
                    }
                    // 여러 줄에 걸친 표 시작
                    insideTable = true;
                    tableBuffer = line + '\n';
                    continue;
                }
                
                // 표 내용 수집
                if (insideTable) {
                    tableBuffer += line + '\n';
                    if (trimmed.includes('</table>')) {
                        // 표 종료 - 변환
                        bodyContent += convertHtmlTableToOoxml(tableBuffer);
                        insideTable = false;
                        tableBuffer = '';
                    }
                    continue;
                }
                
                // 일반 텍스트 (font size 12pt = w:sz val 24)
                bodyContent += `<w:p><w:pPr><w:rPr><w:sz w:val="24"/><w:szCs w:val="24"/></w:rPr></w:pPr>${parseOoxmlWithSize(line)}</w:p>`;
            }
            
            const docXml = `<?xml version="1.0" encoding="UTF-8"?><w:document xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main"><w:body>${bodyContent}<w:sectPr><w:pgSz w:w="12240" w:h="15840"/><w:pgMar w:top="1440" w:right="1440" w:bottom="1440" w:left="1440"/></w:sectPr></w:body></w:document>`;
            const ctXml = `<?xml version="1.0" encoding="UTF-8"?><Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types"><Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/><Default Extension="xml" ContentType="application/xml"/><Override PartName="/word/document.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml"/></Types>`;
            const relXml = `<?xml version="1.0" encoding="UTF-8"?><Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="word/document.xml"/></Relationships>`;
            const drXml = `<?xml version="1.0" encoding="UTF-8"?><Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"/>`;
            const zip = new JSZip();
            zip.file('[Content_Types].xml', ctXml);
            zip.folder('_rels').file('.rels', relXml);
            zip.folder('word').file('document.xml', docXml);
            zip.folder('word/_rels').file('document.xml.rels', drXml);
            saveAs(await zip.generateAsync({type:'blob',mimeType:'application/vnd.openxmlformats-officedocument.wordprocessingml.document'}), filename+'.docx');
            msgElement.textContent = '✅ 워드 파일(.docx)이 생성되었습니다!'; 
            msgElement.className = 'message success';
            setTimeout(() => msgElement.classList.add('hidden'), 3000);
        }
        
        // parseOoxml with font size 12pt
        function parseOoxmlWithSize(line) {
            const re = /<(sub|sup)>(.*?)<\/\1>/gi;
            let res = '', last = 0, m;
            while ((m = re.exec(line)) !== null) {
                if (m.index > last) {
                    const t = escapeXml(line.slice(last, m.index));
                    if (t) res += `<w:r><w:rPr><w:sz w:val="24"/><w:szCs w:val="24"/></w:rPr><w:t xml:space="preserve">${t}</w:t></w:r>`;
                }
                const tag = m[1].toLowerCase();
                const vert = tag === 'sub' ? 'subscript' : 'superscript';
                res += `<w:r><w:rPr><w:vertAlign w:val="${vert}"/><w:sz w:val="24"/><w:szCs w:val="24"/></w:rPr><w:t xml:space="preserve">${escapeXml(m[2])}</w:t></w:r>`;
                last = re.lastIndex;
            }
            if (last < line.length) {
                const t = escapeXml(line.slice(last));
                if (t) res += `<w:r><w:rPr><w:sz w:val="24"/><w:szCs w:val="24"/></w:rPr><w:t xml:space="preserve">${t}</w:t></w:r>`;
            }
            return res;
        }
        
        function clearAll1() {
            if (!confirm('모든 내용을 지우시겠습니까?')) return;
            document.getElementById('textInput1').value = '';
            document.getElementById('fileName1').textContent = '또는 아래에 .docx 파일을 드래그하세요';
            document.getElementById('fileInput1').value = '';
            document.getElementById('priorityYear').value = '';
            document.getElementById('priorityMonth').value = '';
            document.getElementById('priorityDay').value = '';
            document.getElementById('priorityNumber').value = '';
            document.getElementById('output1').innerHTML = '';
            document.getElementById('preview1').innerHTML = '';
            document.getElementById('result1Section').classList.add('hidden');
            document.getElementById('output1Section').classList.add('hidden');
            document.getElementById('fileAnalysis1').classList.add('hidden');
            document.getElementById('crossRefMessage').classList.add('hidden');
            document.getElementById('subtitleMessage').classList.add('hidden');
            document.getElementById('paragraphNumMessage').classList.add('hidden');
            rawOutput1 = '';
            fileAnalysisResult = { hasCrossRef: false, hasScript: false, hasParagraphNum: false, hasTable: false };
            document.getElementById('subCount1').textContent = '0';
            document.getElementById('supCount1').textContent = '0';
            document.getElementById('paragraphCount1').textContent = '0';
            document.getElementById('tableCount1').textContent = '0';
            document.getElementById('claimCount1').textContent = '0';
        }
        
        // 탭2
        const inp2 = document.getElementById('htmlInput2');
        inp2.addEventListener('input', updatePreview2);
        function updatePreview2() {
            const t = inp2.value;
            
            // 미리보기 - 표는 실제 HTML로 렌더링
            let previewHtml = t;
            let inTable = false;
            const lines = previewHtml.split('\n');
            let previewLines = [];
            for (let line of lines) {
                const trimmed = line.trim();
                // 페이지 나누기 마커 시각화
                if (trimmed === '<pagebreak/>') {
                    previewLines.push('<div style="border-top:2px dashed #e74c3c;margin:10px 0;padding:5px 0;text-align:center;color:#e74c3c;font-size:0.85em;">--- 페이지 나누기 ---</div>');
                    continue;
                }
                if (line.trim().startsWith('<table')) inTable = true;
                if (inTable) {
                    previewLines.push(line);
                } else {
                    previewLines.push(line + '<br>');
                }
                if (line.trim().endsWith('</table>')) inTable = false;
            }
            document.getElementById('preview2').innerHTML = previewLines.join('') || '입력된 텍스트의 미리보기가 여기에 표시됩니다.';
            
            // 첨자 개수
            document.getElementById('subCount2').textContent = (t.match(/<sub>/gi)||[]).length;
            document.getElementById('supCount2').textContent = (t.match(/<sup>/gi)||[]).length;
            
            // 표 개수
            const tableMatches = t.match(/<table[^>]*>/gi);
            document.getElementById('tableCount2').textContent = tableMatches ? tableMatches.length : 0;
            
            // 단락 개수 (WHAT IS CLAIMED IS: 이전, 마침표로 끝나는 단락만 카운트)
            let paragraphCount = 0;
            let insideTable = false;
            let afterClaimsSection = false;
            for (let line of lines) {
                const trimmed = line.trim();
                
                // pagebreak 마커는 건너뜀
                if (trimmed === '<pagebreak/>') continue;
                
                // WHAT IS CLAIMED IS: 이후는 카운트하지 않음
                if (trimmed === 'WHAT IS CLAIMED IS:' || trimmed === 'WHAT IS CLAIMED IS') {
                    afterClaimsSection = true;
                }
                
                if (trimmed.startsWith('<table')) insideTable = true;
                
                // 단락 카운트 조건: 표 밖, WHAT IS CLAIMED IS: 이전, 마침표로 끝남
                if (!afterClaimsSection && !insideTable && trimmed && 
                    !trimmed.startsWith('<table') && !trimmed.endsWith('</table>') &&
                    /[.。]["']?$/.test(trimmed)) {
                    paragraphCount++;
                }
                
                if (trimmed.endsWith('</table>')) insideTable = false;
            }
            document.getElementById('paragraphCount2').textContent = paragraphCount;
        }
        function loadExample2(type) {
            const ex = {
                chemistry: '물: H<sub>2</sub>O\n이산화탄소: CO<sub>2</sub>\n황산: H<sub>2</sub>SO<sub>4</sub>',
                math: '피타고라스: a<sup>2</sup> + b<sup>2</sup> = c<sup>2</sup>\n거듭제곱: 2<sup>10</sup> = 1024',
                mixed: '아보가드로 수: 6.022 × 10<sup>23</sup>\n황산 이온: SO<sub>4</sub><sup>2-</sup>',
                table: '【표 1】\n<table border="1">\n<tr><td>항목</td><td>설명</td></tr>\n<tr><td>H<sub>2</sub>O</td><td>물</td></tr>\n<tr><td>CO<sub>2</sub></td><td>이산화탄소</td></tr>\n</table>\n위 표는 화학식 예시입니다.'
            };
            inp2.value = ex[type]; updatePreview2();
        }
        
        function clearAll2() {
            if (!confirm('모든 내용을 지우시겠습니까?')) return;
            inp2.value = '';
            document.getElementById('fileName2').textContent = '또는 아래에 .docx 파일을 드래그하세요';
            document.getElementById('fileInput2').value = '';
            document.getElementById('outputFileName2').value = '';
            document.getElementById('preview2').innerHTML = '입력된 텍스트의 미리보기가 여기에 표시됩니다.';
            document.getElementById('subCount2').textContent = '0';
            document.getElementById('supCount2').textContent = '0';
            document.getElementById('paragraphCount2').textContent = '0';
            document.getElementById('tableCount2').textContent = '0';
            // 우선권 입력 필드 초기화
            document.getElementById('priorityYear2').value = '';
            document.getElementById('priorityMonth2').value = '';
            document.getElementById('priorityDay2').value = '';
            document.getElementById('priorityNumber2').value = '';
            // 메시지 초기화
            document.getElementById('crossRefMessage2').classList.add('hidden');
            document.getElementById('subtitleMessage2').classList.add('hidden');
            document.getElementById('paragraphNumMessage2').classList.add('hidden');
        }
        
        // 탭2 파일 업로드 처리
        async function handleFile2(file) {
            if (!file) return;
            if (!file.name.toLowerCase().endsWith('.docx')) {
                alert('❌ .docx 파일만 업로드 가능합니다.');
                return;
            }
            document.getElementById('fileName2').textContent = file.name;
            try {
                const result = await processDocx1(file); // 동일한 파싱 함수 사용
                inp2.value = result.text;
                updatePreview2();
            } catch (error) { alert('오류: ' + error.message); }
        }
        
        // 탭2 파일 선택 버튼
        document.getElementById('fileInput2').addEventListener('change', async function(e) {
            const file = e.target.files[0];
            await handleFile2(file);
        });
        
        // 탭2 드래그 앤 드롭
        inp2.addEventListener('dragover', function(e) {
            e.preventDefault();
            e.stopPropagation();
            this.classList.add('drag-over');
        });
        
        inp2.addEventListener('dragleave', function(e) {
            e.preventDefault();
            e.stopPropagation();
            this.classList.remove('drag-over');
        });
        
        inp2.addEventListener('drop', async function(e) {
            e.preventDefault();
            e.stopPropagation();
            this.classList.remove('drag-over');
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                await handleFile2(files[0]);
            }
        });
        
        // 탭2 Cross-reference 삽입 함수
        function insertCrossReference2() {
            const msg = document.getElementById('crossRefMessage2');
            msg.classList.add('hidden');
            
            const currentText = inp2.value;
            
            // 텍스트 입력 확인
            if (!currentText.trim()) {
                msg.textContent = '❌ 먼저 텍스트를 입력하거나 워드 파일을 업로드해주세요.';
                msg.className = 'message error';
                return;
            }
            
            // 이미 Cross-reference가 존재하는지 확인
            if (/CROSS-REFERENCE/i.test(currentText)) {
                msg.textContent = '⚠️ 이미 Cross-reference가 존재합니다.';
                msg.className = 'message error';
                return;
            }
            
            // 우선권출원 정보 확인
            const year = document.getElementById('priorityYear2').value.trim();
            const month = document.getElementById('priorityMonth2').value.trim();
            const day = document.getElementById('priorityDay2').value.trim();
            const appNum = document.getElementById('priorityNumber2').value.trim();
            
            if (!year || !month || !day || !appNum) {
                msg.textContent = '❌ 모든 우선권출원 정보를 입력해주세요.';
                msg.className = 'message error';
                return;
            }
            
            // 월 영문 변환
            const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 
                                'July', 'August', 'September', 'October', 'November', 'December'];
            const monthEng = monthNames[parseInt(month) - 1] || month;
            
            // Cross-reference 텍스트 생성 (영문)
            const crossRef = `CROSS-REFERENCE TO RELATED APPLICATIONS\nThis application is based on Korean Patent Application No. ${appNum}, filed on ${monthEng} ${parseInt(day)}, ${year}, the entire contents of which are incorporated herein by reference.`;
            
            // BACKGROUND로 시작하는 단락 찾기
            const lines = currentText.split('\n');
            let insertIndex = -1;
            for (let i = 0; i < lines.length; i++) {
                if (lines[i].trim().toUpperCase().startsWith('BACKGROUND')) {
                    insertIndex = i;
                    break;
                }
            }
            
            if (insertIndex < 0) {
                msg.textContent = '❌ BACKGROUND 단락을 찾을 수 없습니다.';
                msg.className = 'message error';
                return;
            }
            
            // 삽입 (빈줄 없이)
            lines.splice(insertIndex, 0, crossRef);
            inp2.value = lines.join('\n');
            
            // 미리보기 업데이트
            updatePreview2();
            
            msg.textContent = '✅ Cross-reference가 삽입되었습니다!';
            msg.className = 'message success';
            setTimeout(() => msg.classList.add('hidden'), 3000);
        }
        
        // 탭2 부제표준화 함수
        function standardizeSubtitles2() {
            const msg = document.getElementById('subtitleMessage2');
            msg.classList.add('hidden');
            
            const currentText = inp2.value;
            
            if (!currentText.trim()) {
                msg.textContent = '❌ 먼저 텍스트를 입력하거나 워드 파일을 업로드해주세요.';
                msg.className = 'message error';
                return;
            }
            
            // 선택된 표준 확인
            const selectedStandard = document.querySelector('input[name="subtitleStandard2"]:checked').value;
            
            let result = currentText;
            let convertedCount = 0;
            
            // 변환 규칙 정의
            const officeUSRules = [
                { from: '【발명의 설명】', to: '', delete: true },
                { from: '【발명의 명칭】', to: 'TITLE OF THE INVENTION' },
                { from: '【기술분야】', to: 'BACKGROUND OF THE INVENTION\n(a) Field of the Invention' },
                { from: '【발명의 배경이 되는 기술】', to: '(b) Description of the Related Art' },
                { from: '【배경기술】', to: '(b) Description of the Related Art' },
                { from: '【발명의 내용】', to: 'SUMMARY OF THE INVENTION' },
                { from: '【해결하고자 하는 과제】', to: '', delete: true },
                { from: '【기술적 과제】', to: '', delete: true },
                { from: '【과제의 해결 수단】', to: '', delete: true },
                { from: '【기술적 해결방법】', to: '', delete: true },
                { from: '【발명의 효과】', to: '', delete: true },
                { from: '【도면의 간단한 설명】', to: 'BRIEF DESCRIPTION OF THE DRAWINGS' },
                { from: '【발명을 실시하기 위한 구체적인 내용】', to: 'DETAILED DESCRIPTION OF THE EMBODIMENTS' },
                { from: '【발명의 실시를 위한 형태】', to: 'DETAILED DESCRIPTION OF THE EMBODIMENTS' },
                { from: '【부호의 설명】', to: 'Description of Symbols' },
                { from: '【청구범위】', to: 'WHAT IS CLAIMED IS:' },
                { from: '【청구의 범위】', to: 'WHAT IS CLAIMED IS:' },
                { from: '【요약서】', to: 'ABSTRACT OF DISCLOSURE' },
                { from: '【요약】', to: '', delete: true },
                { from: '【대표도】', to: 'Representative Drawing:' }
            ];
            
            const sdcUSRules = [
                { from: '【발명의 설명】', to: '', delete: true },
                { from: '【발명의 명칭】', to: '', delete: true },
                { from: '【기술분야】', to: 'BACKGROUND\n1. Field' },
                { from: '【발명의 배경이 되는 기술】', to: '2. Description of the Related Art' },
                { from: '【배경기술】', to: '2. Description of the Related Art' },
                { from: '【발명의 내용】', to: 'SUMMARY' },
                { from: '【해결하고자 하는 과제】', to: '', delete: true },
                { from: '【기술적 과제】', to: '', delete: true },
                { from: '【과제의 해결 수단】', to: '', delete: true },
                { from: '【기술적 해결방법】', to: '', delete: true },
                { from: '【발명의 효과】', to: '', delete: true },
                { from: '【도면의 간단한 설명】', to: 'BRIEF DESCRIPTION OF THE DRAWINGS' },
                { from: '【발명을 실시하기 위한 구체적인 내용】', to: 'DETAILED DESCRIPTION' },
                { from: '【발명의 실시를 위한 형태】', to: 'DETAILED DESCRIPTION' },
                { from: '【부호의 설명】', to: 'Description of Symbols' },
                { from: '【청구범위】', to: 'WHAT IS CLAIMED IS:' },
                { from: '【청구의 범위】', to: 'WHAT IS CLAIMED IS:' },
                { from: '【요약서】', to: 'ABSTRACT' },
                { from: '【요약】', to: '', delete: true },
                { from: '【대표도】', to: 'Representative Drawing:' },
                { from: 'TITLE OF THE INVENTION', to: '', delete: true },
                { from: 'BACKGROUND OF THE INVENTION', to: 'BACKGROUND' },
                { from: '(a) Field of the Invention', to: '1. Field' },
                { from: '(b) Description of the Related Art', to: '2. Description of the Related Art' },
                { from: 'SUMMARY OF THE INVENTION', to: 'SUMMARY' },
                { from: 'DETAILED DESCRIPTION OF THE EMBODIMENTS', to: 'DETAILED DESCRIPTION' },
                { from: 'DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS', to: 'DETAILED DESCRIPTION' },
                { from: 'ABSTRACT OF DISCLOSURE', to: 'ABSTRACT' }
            ];
            
            const pctRules = [
                // 국문부제 -> PCT출원용
                { from: '【발명의 설명】', to: '【DESCRIPTION】' },
                { from: '【발명의 명칭】', to: '【Invention Title】' },
                { from: '【기술분야】', to: '【Technical Field】' },
                { from: '【배경기술】', to: '【Background Art】' },
                { from: '【발명의 배경이 되는 기술】', to: '【Background Art】' },
                { from: '【발명의 내용】', to: '【Disclosure】' },
                { from: '【기술적 과제】', to: '【Technical Problem】' },
                { from: '【해결하고자 하는 과제】', to: '【Technical Problem】' },
                { from: '【기술적 해결방법】', to: '【Technical Solution】' },
                { from: '【과제의 해결 수단】', to: '【Technical Solution】' },
                { from: '【발명의 효과】', to: '【Advantageous Effects】' },
                { from: '【도면의 간단한 설명】', to: '【Description of Drawings】' },
                { from: '【발명의 실시를 위한 최선의 형태】', to: '【Best Mode】' },
                { from: '【발명의 실시를 위한 형태】', to: '【Mode for Invention】' },
                { from: '【발명을 실시하기 위한 구체적인 내용】', to: '【Mode for Invention】' },
                { from: '【산업상 이용가능성】', to: '【Industrial Applicability】' },
                { from: '【서열목록】', to: '【Sequence List Text】' },
                { from: '【부호의 설명】', to: '【Description of Symbols】' },
                { from: '【청구의 범위】', to: '【CLAIMS】' },
                { from: '【청구범위】', to: '【CLAIMS】' },
                { from: '【요약서】', to: '【ABSTRACT】' },
                { from: '【요약】', to: '【ABSTRACT】' },
                { from: '【도면】', to: '【DRAWINGS】' },
                { from: '【대표도】', to: '【Representative Drawing】' },
                // 영문부제(사무소표준US) -> PCT출원용
                { from: 'TITLE OF THE INVENTION', to: '【Invention Title】' },
                { from: 'BACKGROUND OF THE INVENTION', to: '', delete: true },
                { from: '(a) Field of the Invention', to: '【Technical Field】' },
                { from: '(b) Description of the Related Art', to: '【Background Art】' },
                { from: 'SUMMARY OF THE INVENTION', to: '【Disclosure】\n【Technical Problem】\n【Technical Solution】**적소이동필요**\n【Advantageous Effects】**적소이동필요**' },
                { from: 'BRIEF DESCRIPTION OF THE DRAWINGS', to: '【Description of Drawings】' },
                { from: 'DETAILED DESCRIPTION OF THE EMBODIMENTS', to: '【Mode for Invention】' },
                { from: 'DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS', to: '【Mode for Invention】' },
                { from: 'WHAT IS CLAIMED IS:', to: '【CLAIMS】' },
                { from: 'ABSTRACT OF DISCLOSURE', to: '【ABSTRACT】' },
                { from: 'Description of Symbols', to: '【Description of Symbols】' },
                // SDC표준US -> PCT출원용
                { from: 'BACKGROUND', to: '', delete: true },
                { from: '1. Field', to: '【Technical Field】' },
                { from: '2. Description of the Related Art', to: '【Background Art】' },
                { from: 'SUMMARY', to: '【Disclosure】\n【Technical Problem】\n【Technical Solution】**적소이동필요**\n【Advantageous Effects】**적소이동필요**' },
                { from: 'DETAILED DESCRIPTION', to: '【Mode for Invention】' },
                { from: 'ABSTRACT', to: '【ABSTRACT】' }
            ];
            
            // 선택된 표준에 따라 규칙 선택
            let rules = [];
            let standardName = '';
            
            if (selectedStandard === 'office') {
                rules = officeUSRules;
                standardName = '사무소표준US';
            } else if (selectedStandard === 'sdc') {
                rules = sdcUSRules;
                standardName = 'SDC표준US';
            } else if (selectedStandard === 'pct') {
                rules = pctRules;
                standardName = 'PCT출원용';
            }
            
            // 라인 단위로 변환 적용
            const lines = result.split('\n');
            const resultLines = [];
            let figureCount = 0; // 도면 개수 추적
            
            for (let i = 0; i < lines.length; i++) {
                let line = lines[i];
                let trimmedLine = line.trim();
                let matched = false;
                
                for (const rule of rules) {
                    if (trimmedLine === rule.from) {
                        matched = true;
                        convertedCount++;
                        if (rule.delete) {
                            // 삭제 (라인 건너뜀)
                        } else {
                            // 변환 적용 (여러 줄일 수 있음)
                            const newLines = rule.to.split('\n');
                            newLines.forEach(nl => resultLines.push(nl));
                        }
                        break;
                    }
                }
                
                // PCT 출원용 특수 패턴 처리
                if (!matched && selectedStandard === 'pct') {
                    // 【청구항 X】 -> 【Claim X】 패턴 처리
                    const claimMatch = trimmedLine.match(/^【청구항\s*(\d+)】$/);
                    if (claimMatch) {
                        resultLines.push(`【Claim ${claimMatch[1]}】`);
                        matched = true;
                        convertedCount++;
                    }
                    
                    // 【도 X】 -> 【Figure X】 패턴 처리
                    const figMatch = trimmedLine.match(/^【도\s*(\d+)】$/);
                    if (figMatch) {
                        resultLines.push(`【Figure ${figMatch[1]}】`);
                        matched = true;
                        convertedCount++;
                        figureCount = Math.max(figureCount, parseInt(figMatch[1]));
                    }
                    
                    // 청구항 번호 패턴: "X." 또는 "X. " (줄의 시작) -> 【Claim X】
                    const claimNumMatch = trimmedLine.match(/^(\d+)\.\s+(.*)$/);
                    if (claimNumMatch) {
                        resultLines.push(`【Claim ${claimNumMatch[1]}】`);
                        resultLines.push(claimNumMatch[2]); // 청구항 내용
                        matched = true;
                        convertedCount++;
                    }
                    
                    // FIG. X 또는 Fig. X 패턴 카운트 (도면 개수 파악용)
                    const figRefMatch = trimmedLine.match(/(?:FIG\.|Fig\.)\s*(\d+)/gi);
                    if (figRefMatch) {
                        figRefMatch.forEach(m => {
                            const num = parseInt(m.match(/\d+/)[0]);
                            figureCount = Math.max(figureCount, num);
                        });
                    }
                }
                
                if (!matched) {
                    resultLines.push(line);
                }
            }
            
            // PCT 출원용: 문서 맨 앞에 【DESCRIPTION】 추가 (없는 경우)
            if (selectedStandard === 'pct') {
                const hasDescription = resultLines.some(line => 
                    line.trim() === '【DESCRIPTION】' || line.trim() === '【발명의 설명】'
                );
                if (!hasDescription) {
                    resultLines.unshift('【DESCRIPTION】');
                    convertedCount++;
                }
                
                // 문서 마지막에 【DRAWINGS】와 【Figure X】 추가 (도면 참조가 있는 경우)
                if (figureCount > 0) {
                    const hasDrawings = resultLines.some(line => 
                        line.trim() === '【DRAWINGS】' || line.trim() === '【도면】'
                    );
                    if (!hasDrawings) {
                        resultLines.push('【DRAWINGS】');
                        for (let f = 1; f <= figureCount; f++) {
                            resultLines.push(`【Figure ${f}】`);
                        }
                        convertedCount++;
                    }
                }
            }
            
            result = resultLines.join('\n');
            
            if (convertedCount === 0) {
                msg.textContent = '⚠️ 변환할 부제를 찾지 못했습니다. 문서에 국문 또는 영문 부제가 있는지 확인해주세요.';
                msg.className = 'message error';
                return;
            }
            
            // 결과 적용
            inp2.value = result;
            
            // 미리보기 업데이트
            updatePreview2();
            
            msg.textContent = `✅ 부제표준화 완료! (${standardName} 형식, ${convertedCount}개 부제 변환됨)`;
            msg.className = 'message success';
            setTimeout(() => msg.classList.add('hidden'), 5000);
        }
        
        // 양식표준화 공통 로직 (텍스트 입력, 결과 반환)
        function applyFormatStandardization(text) {
            const lines = text.split('\n');
            const resultLines = [];
            let inClaims = false;
            let changeCount = 0;
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const trimmed = line.trim();
                const upperTrimmed = trimmed.toUpperCase();
                
                // CROSS-REFERENCE TO RELATED APPLICATIONS 앞에 1줄 추가
                if (upperTrimmed === 'CROSS-REFERENCE TO RELATED APPLICATIONS' || 
                    upperTrimmed === 'CROSS-REFERENCE TO RELATED APPLICATION') {
                    if (resultLines.length > 0 && resultLines[resultLines.length - 1].trim() !== '') {
                        resultLines.push('');
                        changeCount++;
                    }
                    resultLines.push(line);
                    continue;
                }
                
                // BACKGROUND 또는 BACKGROUND OF THE INVENTION 앞에 1줄 추가
                if (upperTrimmed === 'BACKGROUND' || 
                    upperTrimmed === 'BACKGROUND OF THE INVENTION') {
                    if (resultLines.length > 0 && resultLines[resultLines.length - 1].trim() !== '') {
                        resultLines.push('');
                        changeCount++;
                    }
                    resultLines.push(line);
                    continue;
                }
                
                // WHAT IS CLAIMED IS: 앞에 페이지 나누기
                if (upperTrimmed === 'WHAT IS CLAIMED IS:' || upperTrimmed === 'WHAT IS CLAIMED IS') {
                    resultLines.push('<pagebreak/>');
                    resultLines.push(line);
                    inClaims = true;
                    changeCount++;
                    continue;
                }
                
                // ABSTRACT 또는 ABSTRACT OF DISCLOSURE 앞에 페이지 나누기
                if (upperTrimmed === 'ABSTRACT' || upperTrimmed === 'ABSTRACT OF DISCLOSURE') {
                    resultLines.push('<pagebreak/>');
                    resultLines.push(line);
                    changeCount++;
                    continue;
                }
                
                // WHAT IS CLAIMED IS: 이후 번호로 시작하는 단락 앞에 1줄 추가
                if (inClaims && /^\d+\.\s/.test(trimmed)) {
                    if (resultLines.length > 0 && resultLines[resultLines.length - 1].trim() !== '' && 
                        resultLines[resultLines.length - 1].trim() !== '<pagebreak/>') {
                        resultLines.push('');
                        changeCount++;
                    }
                    resultLines.push(line);
                    continue;
                }
                
                resultLines.push(line);
            }
            
            return { text: resultLines.join('\n'), changeCount: changeCount };
        }
        
        // 탭2 양식표준화
        function standardizeFormat2() {
            const msg = document.getElementById('formatMessage2');
            msg.classList.add('hidden');
            
            const text = inp2.value;
            if (!text.trim()) {
                msg.textContent = '❌ 먼저 텍스트를 입력해주세요.';
                msg.className = 'message error';
                return;
            }
            
            const result = applyFormatStandardization(text);
            
            if (result.changeCount === 0) {
                msg.textContent = '❌ 적용할 양식 변경이 없습니다.';
                msg.className = 'message error';
                return;
            }
            
            inp2.value = result.text;
            updatePreview2();
            
            msg.textContent = `✅ 양식표준화 완료! (${result.changeCount}개 변경 적용)`;
            msg.className = 'message success';
            setTimeout(() => msg.classList.add('hidden'), 3000);
        }
        
        // 탭2 단락번호 추가
        function addParagraphNumbers2() {
            const msg = document.getElementById('paragraphNumMessage2');
            msg.classList.add('hidden');
            
            const text = inp2.value;
            if (!text.trim()) {
                msg.textContent = '❌ 먼저 텍스트를 입력해주세요.';
                msg.className = 'message error';
                return;
            }
            
            // 이미 단락번호가 있는지 확인 (0으로 시작하는 4~5자리, 뒤에 공백)
            if (/^\[0\d{3,4}\]\s/m.test(text)) {
                msg.textContent = '⚠️ 이미 단락번호가 존재합니다. 단락번호를 제거한 후 다시 시도해주세요.';
                msg.className = 'message error';
                return;
            }
            
            // 부제목 판별 함수
            function isSubtitle2(line) {
                const trimmed = line.trim();
                if (!trimmed) return false;
                
                // 【】로 묶인 타이틀
                if (/^【[^】]+】$/.test(trimmed)) return true;
                
                // [] 로 묶인 타이틀
                if (/^\[[^\]]+\]$/.test(trimmed) && trimmed.length <= 30) return true;
                
                // 영어 대문자로만 이루어진 부제목
                const upperCount = (trimmed.match(/[A-Z]/g) || []).length;
                const lowerCount = (trimmed.match(/[a-z]/g) || []).length;
                if (upperCount >= 2 && lowerCount === 0 && /^[A-Z0-9\s\-:\/,]+$/.test(trimmed)) return true;
                
                // Description of Symbols
                if (/^<?\s*Description\s+of\s+Symbols\s*>?$/i.test(trimmed)) return true;
                
                return false;
            }
            
            // 청구항 시작 판별 함수 (종료 지점)
            function isClaimsStart2(line) {
                const trimmed = line.trim();
                const upper = trimmed.toUpperCase();
                if (upper === 'WHAT IS CLAIMED IS:' || upper === 'WHAT IS CLAIMED IS') return true;
                if (trimmed === '【CLAIMS】' || trimmed === '【청구의 범위】' || trimmed === '【청구범위】') return true;
                return false;
            }
            
            const lines = text.split('\n');
            
            // 종료 지점 찾기 (WHAT IS CLAIMED IS: 또는 【CLAIMS】)
            let stopIndex = -1;
            for (let i = 0; i < lines.length; i++) {
                if (isClaimsStart2(lines[i])) {
                    stopIndex = i;
                    break;
                }
            }
            
            let counter = 1;
            let insideTable = false;
            const resultLines = [];
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const trimmed = line.trim();
                
                // 표 시작/종료 감지
                if (trimmed.startsWith('<table')) {
                    insideTable = true;
                }
                if (trimmed.endsWith('</table>')) {
                    insideTable = false;
                    resultLines.push(line);
                    continue;
                }
                
                // 종료 지점 도달 시 번호 추가 중단
                let stopNumbering = (stopIndex >= 0 && i >= stopIndex);
                
                // 번호 붙이기 로직 (마침표로 끝나는 단락만)
                if (!stopNumbering && trimmed && !isSubtitle2(line) && !insideTable && /[.。]["']?$/.test(trimmed)) {
                    if (!/^\[\d{4,5}\]\s/.test(trimmed)) {
                        const paraNum = '[' + counter.toString().padStart(4, '0') + '] ';
                        resultLines.push(paraNum + line);
                        counter++;
                    } else {
                        resultLines.push(line);
                    }
                } else {
                    resultLines.push(line);
                }
            }
            
            inp2.value = resultLines.join('\n');
            updatePreview2();
            
            msg.textContent = `✅ 단락번호가 추가되었습니다! (총 ${counter - 1}개 단락)`;
            msg.className = 'message success';
            setTimeout(() => msg.classList.add('hidden'), 3000);
        }
        
        // 탭2 단락번호 제거
        function removeParagraphNumbers2() {
            const msg = document.getElementById('paragraphNumMessage2');
            msg.classList.add('hidden');
            
            const text = inp2.value;
            if (!text.trim()) {
                msg.textContent = '❌ 먼저 텍스트를 입력해주세요.';
                msg.className = 'message error';
                return;
            }
            
            const lines = text.split('\n');
            let removedCount = 0;
            const resultLines = lines.map(line => {
                // 임의 자릿수, 공백 유무 상관없이 단락번호 제거
                if (/^\[\d+\]/.test(line)) {
                    removedCount++;
                    return line.replace(/^\[\d+\]\s?/, '');
                }
                return line;
            });
            
            if (removedCount === 0) {
                msg.textContent = '❌ 제거할 단락번호가 없습니다.';
                msg.className = 'message error';
                return;
            }
            
            inp2.value = resultLines.join('\n');
            updatePreview2();
            
            msg.textContent = `✅ 단락번호가 제거되었습니다! (${removedCount}개 제거)`;
            msg.className = 'message success';
            setTimeout(() => msg.classList.add('hidden'), 3000);
        }
        
        // escapeXml은 utils.js에서 로드됨
        function parseOoxml(line) {
            const re = /<(sub|sup)>(.*?)<\/\1>/gi;
            let res = '', last = 0, m;
            while ((m = re.exec(line)) !== null) {
                if (m.index > last) res += `<w:r><w:t xml:space="preserve">${escapeXml(line.substring(last, m.index))}</w:t></w:r>`;
                res += `<w:r><w:rPr><w:vertAlign w:val="${m[1]==='sub'?'subscript':'superscript'}"/></w:rPr><w:t>${escapeXml(m[2])}</w:t></w:r>`;
                last = re.lastIndex;
            }
            if (last < line.length) res += `<w:r><w:t xml:space="preserve">${escapeXml(line.substring(last))}</w:t></w:r>`;
            return res;
        }
        
        // HTML 표를 OOXML 표로 변환 (정규식 기반)
        function convertHtmlTableToOoxml(tableHtml) {
            // 행 추출
            const trMatches = tableHtml.match(/<tr[^>]*>([\s\S]*?)<\/tr>/gi);
            if (!trMatches || trMatches.length === 0) return '';
            
            // 열 개수 계산
            let maxCols = 0;
            trMatches.forEach(tr => {
                let colCount = 0;
                const tdMatches = tr.match(/<t[dh][^>]*>([\s\S]*?)<\/t[dh]>/gi);
                if (tdMatches) {
                    tdMatches.forEach(td => {
                        const colspanMatch = td.match(/colspan\s*=\s*["']?(\d+)["']?/i);
                        colCount += colspanMatch ? parseInt(colspanMatch[1]) : 1;
                    });
                }
                maxCols = Math.max(maxCols, colCount);
            });
            
            if (maxCols === 0) return '';
            
            // 테이블 XML 생성
            let tblXml = '<w:tbl>';
            
            // 테이블 속성 (테두리 설정)
            tblXml += '<w:tblPr>';
            tblXml += '<w:tblStyle w:val="TableGrid"/>';
            tblXml += '<w:tblW w:w="0" w:type="auto"/>';
            tblXml += '<w:tblBorders>';
            tblXml += '<w:top w:val="single" w:sz="4" w:space="0" w:color="000000"/>';
            tblXml += '<w:left w:val="single" w:sz="4" w:space="0" w:color="000000"/>';
            tblXml += '<w:bottom w:val="single" w:sz="4" w:space="0" w:color="000000"/>';
            tblXml += '<w:right w:val="single" w:sz="4" w:space="0" w:color="000000"/>';
            tblXml += '<w:insideH w:val="single" w:sz="4" w:space="0" w:color="000000"/>';
            tblXml += '<w:insideV w:val="single" w:sz="4" w:space="0" w:color="000000"/>';
            tblXml += '</w:tblBorders>';
            tblXml += '</w:tblPr>';
            
            // 테이블 그리드
            tblXml += '<w:tblGrid>';
            for (let i = 0; i < maxCols; i++) {
                tblXml += '<w:gridCol w:w="2000"/>';
            }
            tblXml += '</w:tblGrid>';
            
            // 행 처리
            trMatches.forEach(tr => {
                tblXml += '<w:tr>';
                const tdMatches = tr.match(/<t[dh][^>]*>([\s\S]*?)<\/t[dh]>/gi);
                if (tdMatches) {
                    tdMatches.forEach(td => {
                        tblXml += '<w:tc>';
                        
                        // colspan 추출
                        const colspanMatch = td.match(/colspan\s*=\s*["']?(\d+)["']?/i);
                        if (colspanMatch && parseInt(colspanMatch[1]) > 1) {
                            tblXml += '<w:tcPr>';
                            tblXml += `<w:gridSpan w:val="${colspanMatch[1]}"/>`;
                            tblXml += '</w:tcPr>';
                        }
                        
                        // 셀 내용 추출 (태그 제거하고 내용만)
                        let cellContent = td.replace(/<t[dh][^>]*>/i, '').replace(/<\/t[dh]>/i, '');
                        // <br> 태그를 줄바꿈으로 변환
                        cellContent = cellContent.replace(/<br\s*\/?>/gi, '\n');
                        
                        // 여러 줄이면 여러 단락으로
                        const lines = cellContent.split('\n');
                        let hasContent = false;
                        lines.forEach(line => {
                            if (line.trim()) {
                                tblXml += `<w:p>${parseOoxml(line)}</w:p>`;
                                hasContent = true;
                            }
                        });
                        
                        // 빈 셀이면 빈 단락 추가
                        if (!hasContent) {
                            tblXml += '<w:p></w:p>';
                        }
                        
                        tblXml += '</w:tc>';
                    });
                }
                tblXml += '</w:tr>';
            });
            
            tblXml += '</w:tbl>';
            return tblXml;
        }
        
        async function convertToDocx2() {
            const t = inp2.value.trim(), msg = document.getElementById('message2');
            msg.classList.add('hidden');
            if (!t) { msg.textContent = '❌ 텍스트를 입력해주세요.'; msg.className = 'message error'; return; }
            const fn = document.getElementById('outputFileName2').value.trim() || 'output';
            try {
                await generateDocxCommon(t, fn, msg);
            } catch (e) { msg.textContent = '❌ 오류: ' + e.message; msg.className = 'message error'; }
        }
        
        // 탭3 - 워드 파일에서 텍스트 추출
        async function extractTextFromDocx3(file) {
            const zip = await JSZip.loadAsync(await file.arrayBuffer());
            const xml = await zip.file('word/document.xml').async('string');
            const doc = new DOMParser().parseFromString(xml, 'application/xml');
            
            // 단락에서 텍스트 추출 (첨자 포함)
            function extractParagraphText(p) {
                let text = '';
                for (const r of p.getElementsByTagName('w:r')) {
                    let t = '';
                    for (const x of r.getElementsByTagName('w:t')) t += x.textContent || '';
                    if (!t) continue;
                    const rPr = r.getElementsByTagName('w:rPr')[0];
                    const va = rPr?.getElementsByTagName('w:vertAlign')[0]?.getAttribute('w:val');
                    if (va === 'subscript') { 
                        text += `<sub>${t}</sub>`; 
                    } else if (va === 'superscript') { 
                        text += `<sup>${t}</sup>`; 
                    } else {
                        text += t;
                    }
                }
                return text;
            }
            
            // 표를 HTML로 변환
            function convertTableToHtml(tbl) {
                let html = '<table border="1">';
                for (const tr of tbl.getElementsByTagName('w:tr')) {
                    html += '<tr>';
                    for (const tc of tr.getElementsByTagName('w:tc')) {
                        // 셀 병합 처리
                        const tcPr = tc.getElementsByTagName('w:tcPr')[0];
                        const gridSpan = tcPr?.getElementsByTagName('w:gridSpan')[0]?.getAttribute('w:val');
                        const vMerge = tcPr?.getElementsByTagName('w:vMerge')[0];
                        
                        // vMerge가 있고 val이 없으면 병합된 셀 (continue)
                        if (vMerge && !vMerge.getAttribute('w:val')) {
                            continue;
                        }
                        
                        let colspan = gridSpan ? ` colspan="${gridSpan}"` : '';
                        
                        // 셀 내용 추출
                        let cellContent = '';
                        for (const p of tc.getElementsByTagName('w:p')) {
                            const pText = extractParagraphText(p);
                            if (cellContent && pText) cellContent += '<br>';
                            cellContent += pText;
                        }
                        html += `<td${colspan}>${cellContent}</td>`;
                    }
                    html += '</tr>';
                }
                html += '</table>';
                return html;
            }
            
            const results = [];
            const body = doc.getElementsByTagName('w:body')[0];
            if (!body) return '';
            
            // body의 직접 자식만 순회 (표 내부 단락 중복 방지)
            for (const child of body.childNodes) {
                if (child.nodeName === 'w:p') {
                    // 일반 단락
                    const text = extractParagraphText(child);
                    results.push(text);
                } else if (child.nodeName === 'w:tbl') {
                    // 표
                    const tableHtml = convertTableToHtml(child);
                    results.push(tableHtml);
                }
            }
            
            return results.join('\n');
        }
        
        // 탭3 - 파일 처리 공통 함수
        async function handleFile3(file) {
            if (!file) return;
            if (!file.name.toLowerCase().endsWith('.docx')) {
                alert('❌ .docx 파일만 업로드 가능합니다.');
                return;
            }
            document.getElementById('fileName3').textContent = file.name;
            try {
                const text = await extractTextFromDocx3(file);
                document.getElementById('inputText3').value = text;
            } catch (error) { 
                alert('오류: ' + error.message); 
            }
        }
        
        // 탭3 - 파일 선택 버튼
        document.getElementById('fileInput3').addEventListener('change', async function(e) {
            const file = e.target.files[0];
            await handleFile3(file);
        });
        
        // 탭3 - 드래그 앤 드롭 (textarea)
        const inputText3 = document.getElementById('inputText3');
        
        inputText3.addEventListener('dragover', function(e) {
            e.preventDefault();
            e.stopPropagation();
            this.classList.add('drag-over');
        });
        
        inputText3.addEventListener('dragleave', function(e) {
            e.preventDefault();
            e.stopPropagation();
            this.classList.remove('drag-over');
        });
        
        inputText3.addEventListener('drop', async function(e) {
            e.preventDefault();
            e.stopPropagation();
            this.classList.remove('drag-over');
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                await handleFile3(files[0]);
            }
        });
        
        // 탭3
        let lines3 = [], afterClaims = false, afterTitle = false, beforeCross = true;
        
        // Description of Symbols 관련 패턴 체크
        function isDescriptionOfSymbols(s) {
            // 다양한 형태: "Description of Symbols", "<Description of Symbols>", "DESCRIPTION OF SYMBOLS" 등
            return /^<?\s*description\s+of\s+symbols\s*>?$/i.test(s.trim());
        }
        
        function detectType(t) {
            const s = t.trim();
            if (!s.length) { afterTitle = false; return 'empty'; }
            if (s === 'TITLE OF THE INVENTION') { afterTitle = true; return 'subtitle'; }
            if (s === 'CROSS-REFERENCE TO RELATED APPLICATIONS') { beforeCross = false; afterTitle = false; return 'subtitle'; }
            if (s === 'WHAT IS CLAIMED IS:' || s === 'WHAT IS CLAIMED IS') { afterClaims = true; afterTitle = false; return 'subtitle'; }
            // Description of Symbols 체크 (한글 체크보다 먼저)
            if (isDescriptionOfSymbols(s)) { afterTitle = false; return 'subtitle'; }
            if (/[가-힣]/.test(s)) { afterTitle = false; return 'korean'; }
            if (isTitle(s)) { afterTitle = false; return 'english'; }
            if (isSub(s)) { afterTitle = false; return 'subtitle'; }
            if (/[a-zA-Z]/.test(s)) { afterTitle = false; return 'english'; }
            afterTitle = false; return 'other';
        }
        function isTitle(s) {
            const up = (s.match(/[A-Z]/g)||[]).length, lo = (s.match(/[a-z]/g)||[]).length;
            if (afterTitle && up >= 2 && lo === 0 && /^[A-Z0-9\s\-:\/,]+$/.test(s)) return true;
            if (beforeCross && up >= 2 && lo === 0) {
                const kw = ['BACKGROUND','FIELD','DESCRIPTION','SUMMARY','BRIEF','DETAILED','EMBODIMENT','INVENTION','REFERENCE','CROSS-REFERENCE','RELATED','APPLICATIONS'];
                if (!kw.some(k => s.includes(k)) && /^[A-Z0-9\s\-:\/,]+$/.test(s)) return true;
            }
            return false;
        }
        function isSub(s) {
            if (isDescriptionOfSymbols(s)) return true;
            if (/^\([a-zA-Z0-9]+\)/.test(s)) return true;
            if (!afterClaims && /^\d+\./.test(s)) return true;
            const up = (s.match(/[A-Z]/g)||[]).length, lo = (s.match(/[a-z]/g)||[]).length;
            return up >= 2 && lo === 0 && /^[A-Z0-9\s\-:\/]+$/.test(s);
        }
        
        // 단락 개수에서 제외할 라인인지 판별 (부제목, 표, 실시예 등 마침표 없는 단락)
        function isExcludedFromParagraphCount(text) {
            const trimmed = text.trim();
            if (!trimmed) return true;
            
            // 부제목 (subtitle type)은 이미 제외됨
            
            // 표 태그
            if (trimmed.startsWith('<table') || trimmed.endsWith('</table>')) return true;
            if (/<table[^>]*>/.test(trimmed) || /<\/table>/.test(trimmed)) return true;
            
            // 【】 또는 []로 묶인 타이틀 (표, 수학식, 화학식 등)
            if (/^[【\[][^【\[\]】]+[】\]]$/.test(trimmed)) return true;
            
            // 마침표로 끝나지 않는 단락은 제외 (부제목, 제목 성격)
            // 단, 마침표(.), 물음표(?), 느낌표(!)로 끝나는 경우는 실제 단락으로 간주
            // 마침표 뒤에 따옴표가 오는 경우도 포함
            if (!/[.?!。]["']?$/.test(trimmed)) return true;
            
            return false;
        }
        
        // 단락/청구항 개수 계산 (isKorean: 국문본 여부)
        function countParagraphsAndClaims(filteredLines, isKorean = false) {
            let paragraphCount = 0;
            let claimCount = 0;
            let afterClaimsSection = false;
            
            for (const line of filteredLines) {
                const trimmed = line.text.trim();
                
                // WHAT IS CLAIMED IS: 체크
                if (trimmed === 'WHAT IS CLAIMED IS:' || trimmed === 'WHAT IS CLAIMED IS') {
                    afterClaimsSection = true;
                    continue;
                }
                
                if (afterClaimsSection) {
                    if (isKorean) {
                        // 국문본: 【청구항 X】 또는 [청구항 X] 패턴 카운트
                        if (/^[【\[]청구항\s*\d+[】\]]$/.test(trimmed)) {
                            claimCount++;
                        }
                    } else {
                        // 영문본: 숫자로 시작하는 행 카운트
                        if (/^\d+\.?\s/.test(trimmed)) {
                            claimCount++;
                        }
                    }
                } else {
                    // 단락: 부제목이 아니고, 제외 대상이 아닌 경우
                    if (line.type !== 'subtitle' && line.type !== 'empty' && !isExcludedFromParagraphCount(line.text)) {
                        paragraphCount++;
                    }
                }
            }
            
            return { paragraphCount, claimCount };
        }
        
        function analyzeText3() {
            const t = document.getElementById('inputText3').value;
            if (!t.trim()) { alert('텍스트를 입력해주세요.'); return; }
            afterClaims = false; afterTitle = false; beforeCross = true;
            currentFilter3 = 'all';
            lines3 = t.split('\n').map((x,i) => ({id:i, text:x, type:detectType(x)}));
            if (!lines3.filter(l => l.type !== 'empty').length) { alert('유효한 내용이 없습니다.'); return; }
            displayPreview3(); updateStats3(); generateResults3();
            ['stats3Section','preview3Section','result3Section'].forEach(x => document.getElementById(x).classList.remove('hidden'));
            document.getElementById('colorResult3Section').classList.add('hidden');
            // 필터 버튼 초기화
            document.querySelectorAll('#stats3Section .stat-card.clickable').forEach(card => {
                card.classList.remove('active');
                if (card.dataset.filter === 'all') card.classList.add('active');
            });
        }
        function displayPreview3() {
            const c = document.getElementById('paragraphList3');
            c.innerHTML = '';
            const lb = {subtitle:'영어부제목',korean:'한글단락',english:'영어단락'};
            const bc = {subtitle:'badge-subtitle',korean:'badge-korean',english:'badge-english'};
            lines3.forEach(l => {
                if (l.type === 'empty' || l.type === 'other') return;
                const d = document.createElement('div');
                d.className = `paragraph-item type-${l.type}`;
                // HTML 태그를 이스케이프하여 텍스트로 표시
                const escapedText = escapeHtml(l.text);
                d.innerHTML = `<div class="paragraph-header"><span>줄 ${l.id+1}</span><span class="language-badge ${bc[l.type]}">${lb[l.type]}</span></div><div class="paragraph-text">${escapedText}</div>`;
                c.appendChild(d);
            });
        }
        
        let currentFilter3 = 'all';
        
        function filterPreview3(filterType, clickedCard) {
            currentFilter3 = filterType;
            
            // 모든 카드에서 active 클래스 제거
            document.querySelectorAll('#stats3Section .stat-card.clickable').forEach(card => {
                card.classList.remove('active');
            });
            // 클릭된 카드에 active 클래스 추가
            clickedCard.classList.add('active');
            
            // 미리보기 필터링
            const c = document.getElementById('paragraphList3');
            c.innerHTML = '';
            const lb = {subtitle:'영어부제목',korean:'한글단락',english:'영어단락'};
            const bc = {subtitle:'badge-subtitle',korean:'badge-korean',english:'badge-english'};
            
            lines3.forEach(l => {
                if (l.type === 'empty' || l.type === 'other') return;
                
                // 필터 적용
                if (filterType !== 'all' && l.type !== filterType) return;
                
                const d = document.createElement('div');
                d.className = `paragraph-item type-${l.type}`;
                // HTML 태그를 이스케이프하여 텍스트로 표시
                const escapedText = escapeHtml(l.text);
                d.innerHTML = `<div class="paragraph-header"><span>줄 ${l.id+1}</span><span class="language-badge ${bc[l.type]}">${lb[l.type]}</span></div><div class="paragraph-text">${escapedText}</div>`;
                c.appendChild(d);
            });
            
            // 필터링된 결과가 없으면 메시지 표시
            if (c.children.length === 0) {
                c.innerHTML = '<div style="padding:20px;text-align:center;color:#999;">해당 유형의 단락이 없습니다.</div>';
            }
        }
        function updateStats3() {
            document.getElementById('totalCount3').textContent = lines3.filter(l => l.type !== 'empty').length;
            document.getElementById('subtitleCount3').textContent = lines3.filter(l => l.type === 'subtitle').length;
            document.getElementById('koreanCount3').textContent = lines3.filter(l => l.type === 'korean').length;
            document.getElementById('englishCount3').textContent = lines3.filter(l => l.type === 'english').length;
        }
        
        // HTML/Markdown 태그 존재 여부 확인
        function hasRenderableContent(text) {
            // HTML 태그 체크
            const htmlTags = /<(sub|sup|table|tr|td|th|strong|em|b|i|u|code|pre|blockquote|h[1-6]|ul|ol|li|a|img|br|hr)[^>]*>/i;
            if (htmlTags.test(text)) return true;
            
            // Markdown 문법 체크
            const mdPatterns = [
                /\*\*[^*]+\*\*/,           // **bold**
                /\*[^*]+\*/,               // *italic*
                /__[^_]+__/,               // __bold__
                /_[^_]+_/,                 // _italic_
                /`[^`]+`/,                 // `code`
                /^#{1,6}\s/m,              // # heading
                /^\s*[-*+]\s/m,            // - list
                /^\s*\d+\.\s/m,            // 1. ordered list
                /\[.+\]\(.+\)/,            // [link](url)
                /!\[.+\]\(.+\)/,           // ![image](url)
                /^>\s/m,                   // > blockquote
                /^---$/m,                  // horizontal rule
                /\|.+\|/                   // | table |
            ];
            
            for (const pattern of mdPatterns) {
                if (pattern.test(text)) return true;
            }
            
            return false;
        }
        
        // 텍스트를 렌더링 HTML로 변환
        function renderTextToHtml(text) {
            if (!text) return '';
            
            // 줄 단위로 처리
            let lines = text.split('\n');
            let html = '';
            
            for (let line of lines) {
                let rendered = line;
                
                // HTML 태그는 그대로 유지 (이미 HTML인 경우)
                // 단, 특수 문자 이스케이프 필요한 부분 제외
                
                // Markdown bold/italic 변환
                rendered = rendered.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
                rendered = rendered.replace(/__([^_]+)__/g, '<strong>$1</strong>');
                rendered = rendered.replace(/\*([^*]+)\*/g, '<em>$1</em>');
                rendered = rendered.replace(/_([^_]+)_/g, '<em>$1</em>');
                
                // Markdown inline code 변환
                rendered = rendered.replace(/`([^`]+)`/g, '<code>$1</code>');
                
                // Markdown headings 변환
                rendered = rendered.replace(/^######\s+(.+)$/g, '<h6>$1</h6>');
                rendered = rendered.replace(/^#####\s+(.+)$/g, '<h5>$1</h5>');
                rendered = rendered.replace(/^####\s+(.+)$/g, '<h4>$1</h4>');
                rendered = rendered.replace(/^###\s+(.+)$/g, '<h3>$1</h3>');
                rendered = rendered.replace(/^##\s+(.+)$/g, '<h2>$1</h2>');
                rendered = rendered.replace(/^#\s+(.+)$/g, '<h1>$1</h1>');
                
                // Markdown blockquote 변환
                rendered = rendered.replace(/^>\s+(.+)$/g, '<blockquote>$1</blockquote>');
                
                // Markdown horizontal rule 변환
                if (/^---$/.test(rendered) || /^\*\*\*$/.test(rendered)) {
                    rendered = '<hr>';
                }
                
                html += rendered + '<br>\n';
            }
            
            return html;
        }
        
        function generateResults3() {
            // 국문본: subtitle + korean
            const krLines = lines3.filter(l => l.type === 'subtitle' || l.type === 'korean');
            const kr = krLines.map(l => l.text);
            const krText = kr.length ? kr.join('\n') : '국문본에 포함될 내용이 없습니다';
            
            // 영문본: subtitle + english
            const enLines = lines3.filter(l => l.type === 'subtitle' || l.type === 'english');
            const en = enLines.map(l => l.text);
            const enText = en.length ? en.join('\n') : '영문본에 포함될 내용이 없습니다';
            
            // 원본 텍스트 저장 (복사용)
            window.koreanRawText3 = krText;
            window.englishRawText3 = enText;
            
            // 국문본 단락/청구항 개수 계산
            const krStats = countParagraphsAndClaims(krLines, true);
            document.getElementById('koreanParagraphCount3').textContent = krStats.paragraphCount;
            document.getElementById('koreanClaimCount3').textContent = krStats.claimCount;
            
            // 국문본 HTML 태그 카운트
            const krSubCount = (krText.match(/<sub>/gi) || []).length;
            const krSupCount = (krText.match(/<sup>/gi) || []).length;
            const krTableCount = (krText.match(/<table/gi) || []).length;
            document.getElementById('koreanSubCount3').textContent = krSubCount;
            document.getElementById('koreanSupCount3').textContent = krSupCount;
            document.getElementById('koreanTableCount3').textContent = krTableCount;
            
            // 영문본 단락/청구항 개수 계산
            const enStats = countParagraphsAndClaims(enLines, false);
            document.getElementById('englishParagraphCount3').textContent = enStats.paragraphCount;
            document.getElementById('englishClaimCount3').textContent = enStats.claimCount;
            
            // 영문본 HTML 태그 카운트
            const enSubCount = (enText.match(/<sub>/gi) || []).length;
            const enSupCount = (enText.match(/<sup>/gi) || []).length;
            const enTableCount = (enText.match(/<table/gi) || []).length;
            document.getElementById('englishSubCount3').textContent = enSubCount;
            document.getElementById('englishSupCount3').textContent = enSupCount;
            document.getElementById('englishTableCount3').textContent = enTableCount;
            
            // 원본 텍스트 창에 태그 강조 표시 (전처리 탭처럼)
            const krHighlighted = highlightHtmlTags(krText);
            document.getElementById('koreanResult3').innerHTML = krHighlighted;
            
            const enHighlighted = highlightHtmlTags(enText);
            document.getElementById('englishResult3').innerHTML = enHighlighted;
            
            // 렌더링 패널 업데이트 - 국문본 (첨자/표가 있는 경우에만 표시)
            const krRenderPanel = document.getElementById('koreanRenderPanel3');
            const krRender = document.getElementById('koreanRender3');
            const krHasSpecialContent = (krSubCount > 0 || krSupCount > 0 || krTableCount > 0);
            if (krHasSpecialContent) {
                krRenderPanel.style.display = 'block';
                krRender.innerHTML = renderTextToHtml(krText);
            } else {
                krRenderPanel.style.display = 'none';
                krRender.innerHTML = '';
            }
            
            // 렌더링 패널 업데이트 - 영문본 (첨자/표가 있는 경우에만 표시)
            const enRenderPanel = document.getElementById('englishRenderPanel3');
            const enRender = document.getElementById('englishRender3');
            const enHasSpecialContent = (enSubCount > 0 || enSupCount > 0 || enTableCount > 0);
            if (enHasSpecialContent) {
                enRenderPanel.style.display = 'block';
                enRender.innerHTML = renderTextToHtml(enText);
            } else {
                enRenderPanel.style.display = 'none';
                enRender.innerHTML = '';
            }
        }
        
        // HTML 태그를 이스케이프하고 강조 표시하는 함수
        function highlightHtmlTags(text) {
            if (!text) return '';
            
            // 먼저 HTML 이스케이프
            let html = text
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');
            
            // 줄바꿈을 <br>로 변환
            html = html.replace(/\n/g, '<br>');
            
            // 이스케이프된 태그를 색상 클래스로 감싸기
            // 아래첨자 태그
            html = html.replace(/&lt;sub&gt;/gi, '<span class="sub-tag">&lt;sub&gt;</span>');
            html = html.replace(/&lt;\/sub&gt;/gi, '<span class="sub-tag">&lt;/sub&gt;</span>');
            
            // 위첨자 태그
            html = html.replace(/&lt;sup&gt;/gi, '<span class="sup-tag">&lt;sup&gt;</span>');
            html = html.replace(/&lt;\/sup&gt;/gi, '<span class="sup-tag">&lt;/sup&gt;</span>');
            
            // 표 관련 태그
            html = html.replace(/&lt;table[^&]*&gt;/gi, '<span class="table-tag">&lt;table&gt;</span>');
            html = html.replace(/&lt;\/table&gt;/gi, '<span class="table-tag">&lt;/table&gt;</span>');
            html = html.replace(/&lt;tr&gt;/gi, '<span class="table-tag">&lt;tr&gt;</span>');
            html = html.replace(/&lt;\/tr&gt;/gi, '<span class="table-tag">&lt;/tr&gt;</span>');
            html = html.replace(/&lt;td([^&]*)&gt;/gi, '<span class="table-tag">&lt;td$1&gt;</span>');
            html = html.replace(/&lt;\/td&gt;/gi, '<span class="table-tag">&lt;/td&gt;</span>');
            html = html.replace(/&lt;th([^&]*)&gt;/gi, '<span class="table-tag">&lt;th$1&gt;</span>');
            html = html.replace(/&lt;\/th&gt;/gi, '<span class="table-tag">&lt;/th&gt;</span>');
            html = html.replace(/&lt;br&gt;/gi, '<span class="table-tag">&lt;br&gt;</span>');
            
            // 강조 텍스트 (__ __ 형식)
            html = html.replace(/__([^_]+)__/g, '<span style="color:#e74c3c;font-weight:600;">$1</span>');
            
            // Markdown 문법 강조 (보라색)
            html = html.replace(/\*\*([^*]+)\*\*/g, '<span class="md-tag">**$1**</span>');
            html = html.replace(/`([^`]+)`/g, '<span class="md-tag">`$1`</span>');
            
            return html;
        }
        
        function copyKorean3() {
            const t = window.koreanRawText3 || '';
            if (!t || t.includes('없습니다')) { alert('복사할 내용이 없습니다.'); return; }
            navigator.clipboard.writeText(t).then(() => alert('✅ 국문본이 복사되었습니다!'));
        }
        function copyEnglish3() {
            const t = window.englishRawText3 || '';
            if (!t || t.includes('없습니다')) { alert('복사할 내용이 없습니다.'); return; }
            navigator.clipboard.writeText(t).then(() => alert('✅ 영문본이 복사되었습니다!'));
        }
        
        // 국문본 DOCX 다운로드
        async function downloadKorDocx3() {
            const text = window.koreanRawText3 || '';
            if (!text || text.includes('없습니다')) {
                alert('다운로드할 내용이 없습니다.');
                return;
            }
            await generateDocxFromText3(text, 'korean_extracted.docx');
        }
        
        // 영문본 DOCX 다운로드
        async function downloadEngDocx3() {
            const text = window.englishRawText3 || '';
            if (!text || text.includes('없습니다')) {
                alert('다운로드할 내용이 없습니다.');
                return;
            }
            await generateDocxFromText3(text, 'english_extracted.docx');
        }
        
        // 국문 색변환 함수
        function convertKoreanColor3() {
            const t = document.getElementById('inputText3').value;
            if (!t.trim()) { alert('텍스트를 입력해주세요.'); return; }
            
            afterClaims = false; afterTitle = false; beforeCross = true;
            const colorLines = t.split('\n').map((x, i) => ({id: i, text: x, type: detectType(x)}));
            
            if (!colorLines.filter(l => l.type !== 'empty').length) { 
                alert('유효한 내용이 없습니다.'); 
                return; 
            }
            
            // 색변환 데이터 저장
            window.colorLines3 = colorLines;
            window.originalText3 = t;
            
            // 통계 업데이트
            document.getElementById('colorTotalCount3').textContent = colorLines.filter(l => l.type !== 'empty').length;
            document.getElementById('colorSubtitleCount3').textContent = colorLines.filter(l => l.type === 'subtitle').length;
            document.getElementById('colorKoreanCount3').textContent = colorLines.filter(l => l.type === 'korean').length;
            document.getElementById('colorEnglishCount3').textContent = colorLines.filter(l => l.type === 'english').length;
            
            // 미리보기 생성 (국문만 색 적용)
            const previewEl = document.getElementById('colorPreview3');
            let previewHtml = '';
            colorLines.forEach(l => {
                if (l.type === 'empty') {
                    previewHtml += '<br>';
                    return;
                }
                const escapedText = escapeHtml(l.text);
                if (l.type === 'korean') {
                    // 국문 단락은 갈색으로 표시
                    previewHtml += `<div style="color:#993300;margin:3px 0;">${escapedText}</div>`;
                } else if (l.type === 'subtitle') {
                    previewHtml += `<div style="color:#e67e22;font-weight:bold;margin:3px 0;">${escapedText}</div>`;
                } else if (l.type === 'english') {
                    previewHtml += `<div style="color:#2980b9;margin:3px 0;">${escapedText}</div>`;
                } else {
                    previewHtml += `<div style="margin:3px 0;">${escapedText}</div>`;
                }
            });
            previewEl.innerHTML = previewHtml;
            
            // 단락 개수, 첨자, 표 통계 계산
            let paragraphCount = 0;
            let subCount = 0;
            let supCount = 0;
            let tableCount = 0;
            let insideTable = false;
            let afterClaimsSection = false;
            
            colorLines.forEach(l => {
                const trimmed = l.text.trim();
                
                // WHAT IS CLAIMED IS: 이후는 단락 카운트하지 않음
                if (trimmed === 'WHAT IS CLAIMED IS:' || trimmed === 'WHAT IS CLAIMED IS') {
                    afterClaimsSection = true;
                }
                
                if (trimmed.startsWith('<table')) insideTable = true;
                
                // 표 개수
                const tableMatches = l.text.match(/<table[^>]*>/gi);
                if (tableMatches) tableCount += tableMatches.length;
                
                // 첨자 개수
                const subMatches = l.text.match(/<sub>/gi);
                const supMatches = l.text.match(/<sup>/gi);
                if (subMatches) subCount += subMatches.length;
                if (supMatches) supCount += supMatches.length;
                
                // 단락 카운트 조건: 표 밖, WHAT IS CLAIMED IS: 이전, 마침표로 끝남
                if (!afterClaimsSection && !insideTable && trimmed && 
                    !trimmed.startsWith('<table') && !trimmed.endsWith('</table>') &&
                    /[.。]["']?$/.test(trimmed)) {
                    paragraphCount++;
                }
                
                if (trimmed.endsWith('</table>')) insideTable = false;
            });
            
            document.getElementById('colorParagraphCount3').textContent = paragraphCount;
            document.getElementById('colorSubCount3').textContent = subCount;
            document.getElementById('colorSupCount3').textContent = supCount;
            document.getElementById('colorTableCount3').textContent = tableCount;
            
            // 색변환 결과 섹션 표시, 영문/국문 추출 결과 숨기기
            document.getElementById('colorResult3Section').classList.remove('hidden');
            document.getElementById('stats3Section').classList.add('hidden');
            document.getElementById('preview3Section').classList.add('hidden');
            document.getElementById('result3Section').classList.add('hidden');
        }
        
        // 한영혼합본 DOCX 다운로드 (국문 색변환 적용)
        async function downloadColorDocx3() {
            if (!window.colorLines3 || !window.originalText3) {
                alert('먼저 국문 색변환을 실행해주세요.');
                return;
            }
            
            try {
                const zip = new JSZip();
                
                // [Content_Types].xml
                zip.file('[Content_Types].xml', `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
<Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
<Default Extension="xml" ContentType="application/xml"/>
<Override PartName="/word/document.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml"/>
<Override PartName="/word/styles.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml"/>
</Types>`);
                
                // _rels/.rels
                zip.file('_rels/.rels', `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="word/document.xml"/>
</Relationships>`);
                
                // word/_rels/document.xml.rels
                zip.file('word/_rels/document.xml.rels', `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles" Target="styles.xml"/>
</Relationships>`);
                
                // word/styles.xml (font size 12pt)
                zip.file('word/styles.xml', `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:styles xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main">
<w:style w:type="paragraph" w:default="1" w:styleId="Normal">
<w:name w:val="Normal"/>
<w:rPr><w:sz w:val="24"/><w:szCs w:val="24"/></w:rPr>
</w:style>
</w:styles>`);
                
                // word/document.xml 생성
                let bodyContent = '';
                
                for (const line of window.colorLines3) {
                    const trimmed = line.text.trim();
                    
                    // 페이지 나누기 마커 처리
                    if (trimmed === '<pagebreak/>') {
                        bodyContent += '<w:p><w:r><w:br w:type="page"/></w:r></w:p>';
                        continue;
                    }
                    
                    // 빈 줄 처리
                    if (line.type === 'empty' || !trimmed) {
                        bodyContent += '<w:p><w:pPr><w:rPr><w:sz w:val="24"/><w:szCs w:val="24"/></w:rPr></w:pPr></w:p>';
                        continue;
                    }
                    
                    // 표 처리
                    if (line.text.includes('<table')) {
                        bodyContent += convertTableToDocx3(line.text);
                        continue;
                    }
                    
                    // 국문 단락 - 갈색(993300) 적용
                    if (line.type === 'korean') {
                        bodyContent += `<w:p><w:pPr><w:rPr><w:color w:val="993300"/><w:sz w:val="24"/><w:szCs w:val="24"/></w:rPr></w:pPr><w:r><w:rPr><w:color w:val="993300"/><w:sz w:val="24"/><w:szCs w:val="24"/></w:rPr>${convertRunToDocxColor3(line.text, '993300')}</w:r></w:p>`;
                    } else {
                        // 영문/부제목 - 기본 색상
                        bodyContent += `<w:p><w:pPr><w:rPr><w:sz w:val="24"/><w:szCs w:val="24"/></w:rPr></w:pPr><w:r><w:rPr><w:sz w:val="24"/><w:szCs w:val="24"/></w:rPr>${convertRunToDocx3(line.text)}</w:r></w:p>`;
                    }
                }
                
                const documentXml = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:document xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main">
<w:body>${bodyContent}
<w:sectPr><w:pgSz w:w="12240" w:h="15840"/><w:pgMar w:top="1440" w:right="1440" w:bottom="1440" w:left="1440"/></w:sectPr>
</w:body></w:document>`;
                
                zip.file('word/document.xml', documentXml);
                
                const blob = await zip.generateAsync({ type: 'blob' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'mixed_korean_colored.docx';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                alert('✅ 한영혼합본 DOCX 파일이 다운로드되었습니다!');
            } catch (error) {
                console.error('DOCX 생성 오류:', error);
                alert('❌ DOCX 생성 중 오류가 발생했습니다.');
            }
        }
        
        // 텍스트를 DOCX run으로 변환 (색상 적용 버전)
        function convertRunToDocxColor3(text, color) {
            let result = '';
            let i = 0;
            
            while (i < text.length) {
                // <sub> 태그 처리
                if (text.substr(i, 5).toLowerCase() === '<sub>') {
                    const endIdx = text.toLowerCase().indexOf('</sub>', i);
                    if (endIdx !== -1) {
                        const subText = text.substring(i + 5, endIdx);
                        result += `</w:t></w:r><w:r><w:rPr><w:vertAlign w:val="subscript"/><w:color w:val="${color}"/><w:sz w:val="24"/><w:szCs w:val="24"/></w:rPr><w:t>${escapeXml(subText)}</w:t></w:r><w:r><w:rPr><w:color w:val="${color}"/><w:sz w:val="24"/><w:szCs w:val="24"/></w:rPr><w:t>`;
                        i = endIdx + 6;
                        continue;
                    }
                }
                // <sup> 태그 처리
                if (text.substr(i, 5).toLowerCase() === '<sup>') {
                    const endIdx = text.toLowerCase().indexOf('</sup>', i);
                    if (endIdx !== -1) {
                        const supText = text.substring(i + 5, endIdx);
                        result += `</w:t></w:r><w:r><w:rPr><w:vertAlign w:val="superscript"/><w:color w:val="${color}"/><w:sz w:val="24"/><w:szCs w:val="24"/></w:rPr><w:t>${escapeXml(supText)}</w:t></w:r><w:r><w:rPr><w:color w:val="${color}"/><w:sz w:val="24"/><w:szCs w:val="24"/></w:rPr><w:t>`;
                        i = endIdx + 6;
                        continue;
                    }
                }
                // <br> 태그 처리
                if (text.substr(i, 4).toLowerCase() === '<br>' || text.substr(i, 5).toLowerCase() === '<br/>') {
                    result += '</w:t><w:br/><w:t>';
                    i += text.substr(i, 4).toLowerCase() === '<br>' ? 4 : 5;
                    continue;
                }
                result += escapeXml(text[i]);
                i++;
            }
            
            return `<w:t>${result}</w:t>`;
        }
        
        // 색변환용 양식표준화
        function standardizeFormatColor3() {
            const msg = document.getElementById('colorMessage3');
            msg.classList.add('hidden');
            
            if (!window.colorLines3 || !window.originalText3) {
                msg.textContent = '❌ 먼저 국문 색변환을 실행해주세요.';
                msg.className = 'message error';
                return;
            }
            
            const result = applyFormatStandardization(window.originalText3);
            
            if (result.changeCount === 0) {
                msg.textContent = '❌ 적용할 양식 변경이 없습니다.';
                msg.className = 'message error';
                return;
            }
            
            window.originalText3 = result.text;
            // colorLines3도 다시 생성
            afterClaims = false; afterTitle = false; beforeCross = true;
            window.colorLines3 = result.text.split('\n').map((x, i) => ({id: i, text: x, type: detectType(x)}));
            
            // 미리보기 갱신
            updateColorPreview3();
            
            msg.textContent = `✅ 양식표준화 완료! (${result.changeCount}개 변경 적용)`;
            msg.className = 'message success';
            setTimeout(() => msg.classList.add('hidden'), 3000);
        }
        
        // 색변환용 단락번호 추가 (국문단락에만)
        function addParagraphNumbersColor3() {
            const msg = document.getElementById('colorMessage3');
            msg.classList.add('hidden');
            
            if (!window.colorLines3 || !window.originalText3) {
                msg.textContent = '❌ 먼저 국문 색변환을 실행해주세요.';
                msg.className = 'message error';
                return;
            }
            
            // 이미 단락번호가 있는지 확인 (국문단락 중에서)
            // 단락번호 형식: [0001] 또는 [00001] - 0으로 시작하고 뒤에 공백이 있음
            const hasExistingNumbers = window.colorLines3.some(l => 
                l.type === 'korean' && /^\[0\d{3,4}\]\s/.test(l.text.trim())
            );
            if (hasExistingNumbers) {
                msg.textContent = '❌ 이미 단락번호가 있습니다.';
                msg.className = 'message error';
                return;
            }
            
            // 국문단락에만 단락번호 추가
            let paragraphNum = 1;
            let insideTable = false;
            let afterClaimsSection = false;
            let addedCount = 0;
            
            const resultLines = window.colorLines3.map(l => {
                const trimmed = l.text.trim();
                
                // 청구항 시작 이후는 번호 부여 중단
                if (trimmed === 'WHAT IS CLAIMED IS:' || trimmed === 'WHAT IS CLAIMED IS' ||
                    trimmed === '특허청구범위' || trimmed === '청구범위') {
                    afterClaimsSection = true;
                }
                
                // 표 내부 감지
                if (trimmed.startsWith('<table')) insideTable = true;
                if (trimmed.endsWith('</table>')) {
                    insideTable = false;
                    return l.text;
                }
                
                // 국문단락이고, 표 밖이고, 청구항 이전이고, 마침표로 끝나는 경우에만 번호 추가
                if (l.type === 'korean' && !insideTable && !afterClaimsSection && 
                    trimmed && /[.。]["']?$/.test(trimmed)) {
                    const numStr = String(paragraphNum).padStart(4, '0');
                    paragraphNum++;
                    addedCount++;
                    return `[${numStr}] ${l.text}`;
                }
                
                return l.text;
            });
            
            if (addedCount === 0) {
                msg.textContent = '❌ 단락번호를 추가할 국문단락이 없습니다.';
                msg.className = 'message error';
                return;
            }
            
            window.originalText3 = resultLines.join('\n');
            
            // colorLines3도 다시 생성
            afterClaims = false; afterTitle = false; beforeCross = true;
            window.colorLines3 = window.originalText3.split('\n').map((x, i) => ({id: i, text: x, type: detectType(x)}));
            
            // 미리보기 갱신
            updateColorPreview3();
            
            msg.textContent = `✅ 국문단락에 단락번호가 추가되었습니다. (${addedCount}개)`;
            msg.className = 'message success';
            setTimeout(() => msg.classList.add('hidden'), 3000);
        }
        
        // 색변환용 단락번호 제거
        function removeParagraphNumbersColor3() {
            const msg = document.getElementById('colorMessage3');
            msg.classList.add('hidden');
            
            if (!window.colorLines3 || !window.originalText3) {
                msg.textContent = '❌ 먼저 국문 색변환을 실행해주세요.';
                msg.className = 'message error';
                return;
            }
            
            const lines = window.originalText3.split('\n');
            let removedCount = 0;
            const resultLines = lines.map(line => {
                // 마침표로 끝나는 단락의 단락번호만 제거
                if (/^\[\d+\]/.test(line) && /[.。]["']?$/.test(line.trim())) {
                    removedCount++;
                    return line.replace(/^\[\d+\]\s?/, '');
                }
                return line;
            });
            
            if (removedCount === 0) {
                msg.textContent = '❌ 제거할 단락번호가 없습니다.';
                msg.className = 'message error';
                return;
            }
            
            window.originalText3 = resultLines.join('\n');
            
            // colorLines3도 다시 생성
            afterClaims = false; afterTitle = false; beforeCross = true;
            window.colorLines3 = window.originalText3.split('\n').map((x, i) => ({id: i, text: x, type: detectType(x)}));
            
            // 미리보기 갱신
            updateColorPreview3();
            
            msg.textContent = `✅ 단락번호가 제거되었습니다. (${removedCount}개)`;
            msg.className = 'message success';
            setTimeout(() => msg.classList.add('hidden'), 3000);
        }
        
        // 색변환 미리보기 갱신
        function updateColorPreview3() {
            const previewEl = document.getElementById('colorPreview3');
            let previewHtml = '';
            
            window.colorLines3.forEach(l => {
                if (l.type === 'empty') {
                    previewHtml += '<br>';
                    return;
                }
                const escapedText = escapeHtml(l.text);
                if (l.type === 'korean') {
                    previewHtml += `<div style="color:#993300;margin:3px 0;">${escapedText}</div>`;
                } else if (l.type === 'subtitle') {
                    previewHtml += `<div style="color:#e67e22;font-weight:bold;margin:3px 0;">${escapedText}</div>`;
                } else if (l.type === 'english') {
                    previewHtml += `<div style="color:#2980b9;margin:3px 0;">${escapedText}</div>`;
                } else {
                    previewHtml += `<div style="margin:3px 0;">${escapedText}</div>`;
                }
            });
            previewEl.innerHTML = previewHtml;
            
            // 통계 갱신
            document.getElementById('colorTotalCount3').textContent = window.colorLines3.filter(l => l.type !== 'empty').length;
            document.getElementById('colorSubtitleCount3').textContent = window.colorLines3.filter(l => l.type === 'subtitle').length;
            document.getElementById('colorKoreanCount3').textContent = window.colorLines3.filter(l => l.type === 'korean').length;
            document.getElementById('colorEnglishCount3').textContent = window.colorLines3.filter(l => l.type === 'english').length;
            
            // 단락 개수, 첨자, 표 통계 계산
            let paragraphCount = 0;
            let subCount = 0;
            let supCount = 0;
            let tableCount = 0;
            let insideTable = false;
            let afterClaimsSection = false;
            
            window.colorLines3.forEach(l => {
                const trimmed = l.text.trim();
                
                if (trimmed === 'WHAT IS CLAIMED IS:' || trimmed === 'WHAT IS CLAIMED IS') {
                    afterClaimsSection = true;
                }
                
                if (trimmed.startsWith('<table')) insideTable = true;
                
                const tableMatches = l.text.match(/<table[^>]*>/gi);
                if (tableMatches) tableCount += tableMatches.length;
                
                const subMatches = l.text.match(/<sub>/gi);
                const supMatches = l.text.match(/<sup>/gi);
                if (subMatches) subCount += subMatches.length;
                if (supMatches) supCount += supMatches.length;
                
                if (!afterClaimsSection && !insideTable && trimmed && 
                    !trimmed.startsWith('<table') && !trimmed.endsWith('</table>') &&
                    /[.。]["']?$/.test(trimmed)) {
                    paragraphCount++;
                }
                
                if (trimmed.endsWith('</table>')) insideTable = false;
            });
            
            document.getElementById('colorParagraphCount3').textContent = paragraphCount;
            document.getElementById('colorSubCount3').textContent = subCount;
            document.getElementById('colorSupCount3').textContent = supCount;
            document.getElementById('colorTableCount3').textContent = tableCount;
        }
        
        // 영문본 양식표준화
        function standardizeFormatEng3() {
            const msg = document.getElementById('engParagraphNumMessage3');
            msg.classList.add('hidden');
            
            let text = window.englishRawText3 || '';
            if (!text || text.includes('없습니다')) {
                msg.textContent = '❌ 영문본이 없습니다.';
                msg.className = 'message error';
                return;
            }
            
            const result = applyFormatStandardization(text);
            
            if (result.changeCount === 0) {
                msg.textContent = '❌ 적용할 양식 변경이 없습니다.';
                msg.className = 'message error';
                return;
            }
            
            window.englishRawText3 = result.text;
            updateEnglishDisplay3();
            
            msg.textContent = `✅ 양식표준화 완료! (${result.changeCount}개 변경 적용)`;
            msg.className = 'message success';
            setTimeout(() => msg.classList.add('hidden'), 3000);
        }
        
        // 국문본 양식표준화
        function standardizeFormatKor3() {
            const msg = document.getElementById('korParagraphNumMessage3');
            msg.classList.add('hidden');
            
            let text = window.koreanRawText3 || '';
            if (!text || text.includes('없습니다')) {
                msg.textContent = '❌ 국문본이 없습니다.';
                msg.className = 'message error';
                return;
            }
            
            const result = applyFormatStandardization(text);
            
            if (result.changeCount === 0) {
                msg.textContent = '❌ 적용할 양식 변경이 없습니다.';
                msg.className = 'message error';
                return;
            }
            
            window.koreanRawText3 = result.text;
            updateKoreanDisplay3();
            
            msg.textContent = `✅ 양식표준화 완료! (${result.changeCount}개 변경 적용)`;
            msg.className = 'message success';
            setTimeout(() => msg.classList.add('hidden'), 3000);
        }
        
        // 영문본 단락번호 추가
        function addParagraphNumbersEng3() {
            const msg = document.getElementById('engParagraphNumMessage3');
            msg.classList.add('hidden');
            
            let text = window.englishRawText3 || '';
            if (!text || text.includes('없습니다')) {
                msg.textContent = '❌ 영문본이 없습니다.';
                msg.className = 'message error';
                return;
            }
            
            // 이미 단락번호가 있는지 확인 (0으로 시작하는 4~5자리, 뒤에 공백)
            if (/^\[0\d{3,4}\]\s/m.test(text)) {
                msg.textContent = '⚠️ 이미 단락번호가 존재합니다. 단락번호를 제거한 후 다시 시도해주세요.';
                msg.className = 'message error';
                return;
            }
            
            const result = addParagraphNumbersToText(text);
            window.englishRawText3 = result.text;
            updateEnglishDisplay3();
            
            msg.textContent = `✅ 단락번호가 추가되었습니다! (총 ${result.count}개 단락)`;
            msg.className = 'message success';
            setTimeout(() => msg.classList.add('hidden'), 3000);
        }
        
        // 영문본 단락번호 제거
        function removeParagraphNumbersEng3() {
            const msg = document.getElementById('engParagraphNumMessage3');
            msg.classList.add('hidden');
            
            let text = window.englishRawText3 || '';
            if (!text || text.includes('없습니다')) {
                msg.textContent = '❌ 영문본이 없습니다.';
                msg.className = 'message error';
                return;
            }
            
            const lines = text.split('\n');
            let removedCount = 0;
            const resultLines = lines.map(line => {
                const trimmed = line.trim();
                // 마침표로 끝나는 단락에서만 단락번호 제거 (임의 자릿수, 공백 유무 상관없이)
                if (/^\[\d+\]/.test(line) && /[.。]["']?$/.test(trimmed)) {
                    removedCount++;
                    return line.replace(/^\[\d+\]\s?/, '');
                }
                return line;
            });
            
            if (removedCount === 0) {
                msg.textContent = '❌ 제거할 단락번호가 없습니다.';
                msg.className = 'message error';
                return;
            }
            
            window.englishRawText3 = resultLines.join('\n');
            updateEnglishDisplay3();
            
            msg.textContent = `✅ 단락번호가 제거되었습니다! (${removedCount}개 제거)`;
            msg.className = 'message success';
            setTimeout(() => msg.classList.add('hidden'), 3000);
        }
        
        // 국문본 단락번호 추가
        function addParagraphNumbersKor3() {
            const msg = document.getElementById('korParagraphNumMessage3');
            msg.classList.add('hidden');
            
            let text = window.koreanRawText3 || '';
            if (!text || text.includes('없습니다')) {
                msg.textContent = '❌ 국문본이 없습니다.';
                msg.className = 'message error';
                return;
            }
            
            // 이미 단락번호가 있는지 확인 (0으로 시작하는 4~5자리, 뒤에 공백)
            if (/^\[0\d{3,4}\]\s/m.test(text)) {
                msg.textContent = '⚠️ 이미 단락번호가 존재합니다. 단락번호를 제거한 후 다시 시도해주세요.';
                msg.className = 'message error';
                return;
            }
            
            const result = addParagraphNumbersToText(text);
            window.koreanRawText3 = result.text;
            updateKoreanDisplay3();
            
            msg.textContent = `✅ 단락번호가 추가되었습니다! (총 ${result.count}개 단락)`;
            msg.className = 'message success';
            setTimeout(() => msg.classList.add('hidden'), 3000);
        }
        
        // 국문본 단락번호 제거
        function removeParagraphNumbersKor3() {
            const msg = document.getElementById('korParagraphNumMessage3');
            msg.classList.add('hidden');
            
            let text = window.koreanRawText3 || '';
            if (!text || text.includes('없습니다')) {
                msg.textContent = '❌ 국문본이 없습니다.';
                msg.className = 'message error';
                return;
            }
            
            const lines = text.split('\n');
            let removedCount = 0;
            const resultLines = lines.map(line => {
                const trimmed = line.trim();
                // 마침표로 끝나는 단락에서만 단락번호 제거 (임의 자릿수, 공백 유무 상관없이)
                if (/^\[\d+\]/.test(line) && /[.。]["']?$/.test(trimmed)) {
                    removedCount++;
                    return line.replace(/^\[\d+\]\s?/, '');
                }
                return line;
            });
            
            if (removedCount === 0) {
                msg.textContent = '❌ 제거할 단락번호가 없습니다.';
                msg.className = 'message error';
                return;
            }
            
            window.koreanRawText3 = resultLines.join('\n');
            updateKoreanDisplay3();
            
            msg.textContent = `✅ 단락번호가 제거되었습니다! (${removedCount}개 제거)`;
            msg.className = 'message success';
            setTimeout(() => msg.classList.add('hidden'), 3000);
        }
        
        // 텍스트에 단락번호 추가 (공통 함수)
        function addParagraphNumbersToText(text) {
            // 부제목 판별 함수
            function isSubtitle(line) {
                const trimmed = line.trim();
                if (!trimmed) return false;
                
                // 【】로 묶인 타이틀
                if (/^【[^】]+】$/.test(trimmed)) return true;
                
                // [] 로 묶인 타이틀
                if (/^\[[^\]]+\]$/.test(trimmed) && trimmed.length <= 30) return true;
                
                // 영어 대문자로만 이루어진 부제목
                const upperCount = (trimmed.match(/[A-Z]/g) || []).length;
                const lowerCount = (trimmed.match(/[a-z]/g) || []).length;
                if (upperCount >= 2 && lowerCount === 0 && /^[A-Z0-9\s\-:\/,]+$/.test(trimmed)) return true;
                
                return false;
            }
            
            // 청구항 시작 판별 함수 (종료 지점)
            function isClaimsStart(line) {
                const trimmed = line.trim();
                const upper = trimmed.toUpperCase();
                if (upper === 'WHAT IS CLAIMED IS:' || upper === 'WHAT IS CLAIMED IS') return true;
                if (trimmed === '【CLAIMS】' || trimmed === '【청구의 범위】' || trimmed === '【청구범위】') return true;
                return false;
            }
            
            const lines = text.split('\n');
            let counter = 1;
            let stopIndex = -1;
            let insideTable = false;
            
            // 청구항 시작 위치 찾기
            for (let i = 0; i < lines.length; i++) {
                if (isClaimsStart(lines[i])) {
                    stopIndex = i;
                    break;
                }
            }
            
            const resultLines = [];
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const trimmed = line.trim();
                
                // 표 내부 감지
                if (trimmed.toLowerCase().startsWith('<table')) insideTable = true;
                if (trimmed.toLowerCase().includes('</table>')) {
                    insideTable = false;
                    resultLines.push(line);
                    continue;
                }
                
                let stopNumbering = (stopIndex >= 0 && i >= stopIndex);
                
                // 번호 붙이기 로직 (마침표로 끝나는 단락만)
                if (!stopNumbering && trimmed && !isSubtitle(line) && !insideTable && /[.。]["']?$/.test(trimmed)) {
                    if (!/^\[\d{4,5}\]\s/.test(trimmed)) {
                        const paraNum = '[' + counter.toString().padStart(4, '0') + '] ';
                        resultLines.push(paraNum + line);
                        counter++;
                    } else {
                        resultLines.push(line);
                    }
                } else {
                    resultLines.push(line);
                }
            }
            
            return { text: resultLines.join('\n'), count: counter - 1 };
        }
        
        // 영문본 표시 업데이트
        function updateEnglishDisplay3() {
            const text = window.englishRawText3 || '';
            const el = document.getElementById('englishResult3');
            el.innerHTML = text.replace(/</g,'&lt;').replace(/>/g,'&gt;')
                .replace(/&lt;pagebreak\/&gt;/g,'<div style="border-top:2px dashed #e74c3c;margin:5px 0;padding:3px 0;text-align:center;color:#e74c3c;font-size:0.8em;">--- 페이지 나누기 ---</div>')
                .replace(/&lt;sub&gt;/g,'<span class="sub-tag">&lt;sub&gt;</span>')
                .replace(/&lt;\/sub&gt;/g,'<span class="sub-tag">&lt;/sub&gt;</span>')
                .replace(/&lt;sup&gt;/g,'<span class="sup-tag">&lt;sup&gt;</span>')
                .replace(/&lt;\/sup&gt;/g,'<span class="sup-tag">&lt;/sup&gt;</span>')
                .replace(/\[(\d+)\]/g,'<span style="color:#27ae60;font-weight:600;">[$1]</span>')
                .replace(/\n/g,'<br>');
            
            // 렌더링 미리보기
            const renderEl = document.getElementById('englishRender3');
            if (renderEl) {
                renderEl.innerHTML = text.replace(/<pagebreak\/>/g,'<div style="border-top:2px dashed #e74c3c;margin:5px 0;padding:3px 0;text-align:center;color:#e74c3c;font-size:0.8em;">--- 페이지 나누기 ---</div>').replace(/\n/g,'<br>');
            }
        }
        
        // 국문본 표시 업데이트
        function updateKoreanDisplay3() {
            const text = window.koreanRawText3 || '';
            const el = document.getElementById('koreanResult3');
            el.innerHTML = text.replace(/</g,'&lt;').replace(/>/g,'&gt;')
                .replace(/&lt;pagebreak\/&gt;/g,'<div style="border-top:2px dashed #e74c3c;margin:5px 0;padding:3px 0;text-align:center;color:#e74c3c;font-size:0.8em;">--- 페이지 나누기 ---</div>')
                .replace(/&lt;sub&gt;/g,'<span class="sub-tag">&lt;sub&gt;</span>')
                .replace(/&lt;\/sub&gt;/g,'<span class="sub-tag">&lt;/sub&gt;</span>')
                .replace(/&lt;sup&gt;/g,'<span class="sup-tag">&lt;sup&gt;</span>')
                .replace(/&lt;\/sup&gt;/g,'<span class="sup-tag">&lt;/sup&gt;</span>')
                .replace(/\[(\d+)\]/g,'<span style="color:#27ae60;font-weight:600;">[$1]</span>')
                .replace(/\n/g,'<br>');
            
            // 렌더링 미리보기
            const renderEl = document.getElementById('koreanRender3');
            if (renderEl) {
                renderEl.innerHTML = text.replace(/<pagebreak\/>/g,'<div style="border-top:2px dashed #e74c3c;margin:5px 0;padding:3px 0;text-align:center;color:#e74c3c;font-size:0.8em;">--- 페이지 나누기 ---</div>').replace(/\n/g,'<br>');
            }
        }
        
        // 텍스트를 DOCX로 변환하여 다운로드 (HTML 태그 렌더링)
        async function generateDocxFromText3(text, filename) {
            try {
                const zip = new JSZip();
                
                // [Content_Types].xml
                zip.file('[Content_Types].xml', `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
<Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
<Default Extension="xml" ContentType="application/xml"/>
<Override PartName="/word/document.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml"/>
<Override PartName="/word/styles.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml"/>
</Types>`);
                
                // _rels/.rels
                zip.file('_rels/.rels', `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="word/document.xml"/>
</Relationships>`);
                
                // word/_rels/document.xml.rels
                zip.file('word/_rels/document.xml.rels', `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles" Target="styles.xml"/>
</Relationships>`);
                
                // word/styles.xml (font size 12pt = 24 half-points)
                zip.file('word/styles.xml', `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:styles xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main">
<w:style w:type="paragraph" w:default="1" w:styleId="Normal">
<w:name w:val="Normal"/>
<w:rPr><w:sz w:val="24"/><w:szCs w:val="24"/></w:rPr>
</w:style>
</w:styles>`);
                
                // word/document.xml 생성
                let bodyContent = '';
                const paragraphs = text.split('\n');
                
                for (const para of paragraphs) {
                    const trimmed = para.trim();
                    
                    // 페이지 나누기 마커 처리
                    if (trimmed === '<pagebreak/>') {
                        bodyContent += '<w:p><w:r><w:br w:type="page"/></w:r></w:p>';
                        continue;
                    }
                    
                    if (!trimmed) continue;
                    
                    // 표 처리
                    if (para.includes('<table')) {
                        bodyContent += convertTableToDocx3(para);
                    } else {
                        // 일반 단락 처리 (sub, sup 태그 변환) - font size 12pt 명시
                        bodyContent += `<w:p><w:pPr><w:rPr><w:sz w:val="24"/><w:szCs w:val="24"/></w:rPr></w:pPr><w:r><w:rPr><w:sz w:val="24"/><w:szCs w:val="24"/></w:rPr>${convertRunToDocx3(para)}</w:r></w:p>`;
                    }
                }
                
                const documentXml = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:document xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main">
<w:body>${bodyContent}
<w:sectPr><w:pgSz w:w="12240" w:h="15840"/><w:pgMar w:top="1440" w:right="1440" w:bottom="1440" w:left="1440"/></w:sectPr>
</w:body></w:document>`;
                
                zip.file('word/document.xml', documentXml);
                
                const blob = await zip.generateAsync({ type: 'blob' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                alert('✅ DOCX 파일이 다운로드되었습니다!');
            } catch (error) {
                console.error('DOCX 생성 오류:', error);
                alert('❌ DOCX 생성 중 오류가 발생했습니다.');
            }
        }
        
        // 텍스트를 DOCX run으로 변환 (sub, sup 처리) - font size 12pt
        function convertRunToDocx3(text) {
            let result = '';
            let i = 0;
            
            while (i < text.length) {
                // <sub> 태그 처리
                if (text.substr(i, 5).toLowerCase() === '<sub>') {
                    const endIdx = text.toLowerCase().indexOf('</sub>', i);
                    if (endIdx !== -1) {
                        const subText = text.substring(i + 5, endIdx);
                        result += `</w:t></w:r><w:r><w:rPr><w:vertAlign w:val="subscript"/><w:sz w:val="24"/><w:szCs w:val="24"/></w:rPr><w:t>${escapeXml(subText)}</w:t></w:r><w:r><w:rPr><w:sz w:val="24"/><w:szCs w:val="24"/></w:rPr><w:t>`;
                        i = endIdx + 6;
                        continue;
                    }
                }
                // <sup> 태그 처리
                if (text.substr(i, 5).toLowerCase() === '<sup>') {
                    const endIdx = text.toLowerCase().indexOf('</sup>', i);
                    if (endIdx !== -1) {
                        const supText = text.substring(i + 5, endIdx);
                        result += `</w:t></w:r><w:r><w:rPr><w:vertAlign w:val="superscript"/><w:sz w:val="24"/><w:szCs w:val="24"/></w:rPr><w:t>${escapeXml(supText)}</w:t></w:r><w:r><w:rPr><w:sz w:val="24"/><w:szCs w:val="24"/></w:rPr><w:t>`;
                        i = endIdx + 6;
                        continue;
                    }
                }
                // <br> 태그 처리
                if (text.substr(i, 4).toLowerCase() === '<br>' || text.substr(i, 5).toLowerCase() === '<br/>') {
                    result += '</w:t><w:br/><w:t>';
                    i += text.substr(i, 4).toLowerCase() === '<br>' ? 4 : 5;
                    continue;
                }
                result += escapeXml(text[i]);
                i++;
            }
            
            return `<w:t>${result}</w:t>`;
        }
        
        // 표를 DOCX 형식으로 변환
        function convertTableToDocx3(html) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');
            const table = doc.querySelector('table');
            
            if (!table) return `<w:p><w:r><w:t>${escapeXml(html)}</w:t></w:r></w:p>`;
            
            let tableXml = '<w:tbl><w:tblPr><w:tblBorders>';
            tableXml += '<w:top w:val="single" w:sz="4" w:color="000000"/>';
            tableXml += '<w:left w:val="single" w:sz="4" w:color="000000"/>';
            tableXml += '<w:bottom w:val="single" w:sz="4" w:color="000000"/>';
            tableXml += '<w:right w:val="single" w:sz="4" w:color="000000"/>';
            tableXml += '<w:insideH w:val="single" w:sz="4" w:color="000000"/>';
            tableXml += '<w:insideV w:val="single" w:sz="4" w:color="000000"/>';
            tableXml += '</w:tblBorders></w:tblPr>';
            
            const rows = table.querySelectorAll('tr');
            rows.forEach(row => {
                tableXml += '<w:tr>';
                const cells = row.querySelectorAll('td, th');
                cells.forEach(cell => {
                    const colspan = cell.getAttribute('colspan') || 1;
                    const rowspan = cell.getAttribute('rowspan') || 1;
                    
                    tableXml += '<w:tc><w:tcPr>';
                    if (colspan > 1) tableXml += `<w:gridSpan w:val="${colspan}"/>`;
                    if (rowspan > 1) tableXml += `<w:vMerge w:val="restart"/>`;
                    tableXml += '</w:tcPr>';
                    tableXml += `<w:p><w:r>${convertRunToDocx3(cell.innerHTML)}</w:r></w:p>`;
                    tableXml += '</w:tc>';
                });
                tableXml += '</w:tr>';
            });
            
            tableXml += '</w:tbl>';
            return tableXml;
        }
        
        // escapeXml은 utils.js에서 로드됨
        function togglePreview3() {
            const c = document.getElementById('previewContent3'), b = document.getElementById('toggleBtn3');
            if (c.classList.contains('collapsed')) { c.classList.remove('collapsed'); b.textContent = '▲ 접기'; }
            else { c.classList.add('collapsed'); b.textContent = '▼ 펼치기'; }
        }
        function clearAll3() {
            if (!confirm('모든 내용을 지우시겠습니까?')) return;
            document.getElementById('inputText3').value = '';
            document.getElementById('fileName3').textContent = '또는 아래에 .docx 파일을 드래그하세요';
            lines3 = []; afterClaims = false; afterTitle = false; beforeCross = true;
            currentFilter3 = 'all';
            document.getElementById('paragraphList3').innerHTML = '';
            document.getElementById('koreanResult3').innerHTML = '국문본이 여기에 표시됩니다';
            document.getElementById('englishResult3').innerHTML = '영문본이 여기에 표시됩니다';
            // 원본 텍스트 변수 초기화
            window.koreanRawText3 = '';
            window.englishRawText3 = '';
            window.colorLines3 = null;
            window.originalText3 = '';
            ['stats3Section','preview3Section','result3Section','colorResult3Section'].forEach(x => document.getElementById(x).classList.add('hidden'));
            document.getElementById('previewContent3').classList.remove('collapsed');
            document.getElementById('toggleBtn3').textContent = '▲ 접기';
            // 필터 버튼 초기화
            document.querySelectorAll('#stats3Section .stat-card.clickable').forEach(card => {
                card.classList.remove('active');
                if (card.dataset.filter === 'all') card.classList.add('active');
            });
            // 통계 초기화
            document.getElementById('koreanParagraphCount3').textContent = '0';
            document.getElementById('koreanClaimCount3').textContent = '0';
            document.getElementById('koreanSubCount3').textContent = '0';
            document.getElementById('koreanSupCount3').textContent = '0';
            document.getElementById('koreanTableCount3').textContent = '0';
            document.getElementById('englishParagraphCount3').textContent = '0';
            document.getElementById('englishClaimCount3').textContent = '0';
            document.getElementById('englishSubCount3').textContent = '0';
            document.getElementById('englishSupCount3').textContent = '0';
            document.getElementById('englishTableCount3').textContent = '0';
            // 색변환 통계 초기화
            document.getElementById('colorTotalCount3').textContent = '0';
            document.getElementById('colorSubtitleCount3').textContent = '0';
            document.getElementById('colorKoreanCount3').textContent = '0';
            document.getElementById('colorEnglishCount3').textContent = '0';
            document.getElementById('colorParagraphCount3').textContent = '0';
            document.getElementById('colorSubCount3').textContent = '0';
            document.getElementById('colorSupCount3').textContent = '0';
            document.getElementById('colorTableCount3').textContent = '0';
            document.getElementById('colorPreview3').innerHTML = '색변환 미리보기가 여기에 표시됩니다.';
            document.getElementById('colorMessage3').classList.add('hidden');
            // 렌더링 패널 초기화
            document.getElementById('koreanRenderPanel3').style.display = 'none';
            document.getElementById('koreanRender3').innerHTML = '';
            document.getElementById('englishRenderPanel3').style.display = 'none';
            document.getElementById('englishRender3').innerHTML = '';
        }
        
        // 서브탭 전환 함수 (탭3)
        function switchSubTab3(tabType, btn) {
            document.querySelectorAll('#tab3 .sub-tab-btn').forEach(b => b.classList.remove('active'));
            document.querySelectorAll('#tab3 .sub-tab-content').forEach(c => c.classList.remove('active'));
            btn.classList.add('active');
            if (tabType === 'extract') {
                document.getElementById('subTab3Extract').classList.add('active');
            } else {
                document.getElementById('subTab3Merge').classList.add('active');
            }
        }
        
        // ========== 병합 기능 ==========
        let mergeKorParagraphs = [];
        let mergeEngParagraphs = [];
        let mergeResult = '';
        let mergeResultPairs = []; // [{text: '...', type: 'kor'|'eng'}, ...]
        
        // 국문 파일 처리
        async function handleFileKor3(file) {
            if (!file) return;
            if (!file.name.toLowerCase().endsWith('.docx')) {
                alert('❌ .docx 파일만 업로드 가능합니다.');
                return;
            }
            document.getElementById('fileNameKor3').textContent = file.name;
            try {
                const text = await extractTextFromDocx3Simple(file);
                document.getElementById('inputTextKor3').value = text;
            } catch (error) {
                alert('오류: ' + error.message);
            }
        }
        
        // 영문 파일 처리
        async function handleFileEng3(file) {
            if (!file) return;
            if (!file.name.toLowerCase().endsWith('.docx')) {
                alert('❌ .docx 파일만 업로드 가능합니다.');
                return;
            }
            document.getElementById('fileNameEng3').textContent = file.name;
            try {
                const text = await extractTextFromDocx3Simple(file);
                document.getElementById('inputTextEng3').value = text;
            } catch (error) {
                alert('오류: ' + error.message);
            }
        }
        
        // 간단한 텍스트 추출 함수 (첨자, 표 포함)
        async function extractTextFromDocx3Simple(file) {
            const zip = await JSZip.loadAsync(await file.arrayBuffer());
            const xml = await zip.file('word/document.xml').async('string');
            const doc = new DOMParser().parseFromString(xml, 'application/xml');
            
            // 단락에서 텍스트 추출 (첨자 포함)
            function extractParagraphText(p) {
                let text = '';
                for (const r of p.getElementsByTagName('w:r')) {
                    let t = '';
                    for (const x of r.getElementsByTagName('w:t')) t += x.textContent || '';
                    if (!t) continue;
                    const rPr = r.getElementsByTagName('w:rPr')[0];
                    const va = rPr?.getElementsByTagName('w:vertAlign')[0]?.getAttribute('w:val');
                    if (va === 'subscript') { 
                        text += `<sub>${t}</sub>`; 
                    } else if (va === 'superscript') { 
                        text += `<sup>${t}</sup>`; 
                    } else {
                        text += t;
                    }
                }
                return text;
            }
            
            // 표를 HTML로 변환
            function convertTableToHtml(tbl) {
                let html = '<table border="1">';
                for (const tr of tbl.getElementsByTagName('w:tr')) {
                    html += '<tr>';
                    for (const tc of tr.getElementsByTagName('w:tc')) {
                        const tcPr = tc.getElementsByTagName('w:tcPr')[0];
                        const gridSpan = tcPr?.getElementsByTagName('w:gridSpan')[0]?.getAttribute('w:val');
                        const vMerge = tcPr?.getElementsByTagName('w:vMerge')[0];
                        
                        if (vMerge && !vMerge.getAttribute('w:val')) {
                            continue;
                        }
                        
                        let colspan = gridSpan ? ` colspan="${gridSpan}"` : '';
                        let cellContent = '';
                        for (const p of tc.getElementsByTagName('w:p')) {
                            const pText = extractParagraphText(p);
                            if (cellContent && pText) cellContent += '<br>';
                            cellContent += pText;
                        }
                        html += `<td${colspan}>${cellContent}</td>`;
                    }
                    html += '</tr>';
                }
                html += '</table>';
                return html;
            }
            
            const results = [];
            const body = doc.getElementsByTagName('w:body')[0];
            if (!body) return '';
            
            for (const child of body.childNodes) {
                if (child.nodeName === 'w:p') {
                    const text = extractParagraphText(child);
                    if (text.trim()) {
                        results.push(text);
                    }
                } else if (child.nodeName === 'w:tbl') {
                    const tableHtml = convertTableToHtml(child);
                    results.push(tableHtml);
                }
            }
            
            return results.join('\n');
        }
        
        // 파일 선택 이벤트
        document.getElementById('fileInputKor3').addEventListener('change', async function(e) {
            await handleFileKor3(e.target.files[0]);
        });
        document.getElementById('fileInputEng3').addEventListener('change', async function(e) {
            await handleFileEng3(e.target.files[0]);
        });
        
        // 드래그 앤 드롭 이벤트 (국문)
        const inputTextKor3 = document.getElementById('inputTextKor3');
        inputTextKor3.addEventListener('dragover', function(e) {
            e.preventDefault();
            e.stopPropagation();
            this.classList.add('drag-over');
        });
        inputTextKor3.addEventListener('dragleave', function(e) {
            e.preventDefault();
            e.stopPropagation();
            this.classList.remove('drag-over');
        });
        inputTextKor3.addEventListener('drop', async function(e) {
            e.preventDefault();
            e.stopPropagation();
            this.classList.remove('drag-over');
            if (e.dataTransfer.files.length > 0) {
                await handleFileKor3(e.dataTransfer.files[0]);
            }
        });
        
        // 드래그 앤 드롭 이벤트 (영문)
        const inputTextEng3 = document.getElementById('inputTextEng3');
        inputTextEng3.addEventListener('dragover', function(e) {
            e.preventDefault();
            e.stopPropagation();
            this.classList.add('drag-over');
        });
        inputTextEng3.addEventListener('dragleave', function(e) {
            e.preventDefault();
            e.stopPropagation();
            this.classList.remove('drag-over');
        });
        inputTextEng3.addEventListener('drop', async function(e) {
            e.preventDefault();
            e.stopPropagation();
            this.classList.remove('drag-over');
            if (e.dataTransfer.files.length > 0) {
                await handleFileEng3(e.dataTransfer.files[0]);
            }
        });
        
        // 병합 실행
        function mergeDocuments3() {
            const korText = document.getElementById('inputTextKor3').value;
            const engText = document.getElementById('inputTextEng3').value;
            const msg = document.getElementById('merge3Message');
            
            if (!korText.trim() || !engText.trim()) {
                msg.textContent = '❌ 국문명세서와 영문명세서를 모두 입력해주세요.';
                msg.className = 'message error';
                return;
            }
            
            // 단락 분리 (줄 기준)
            const korLines = korText.split(/\n/).map(p => p.trim()).filter(p => p);
            const engLines = engText.split(/\n/).map(p => p.trim()).filter(p => p);
            
            // 단락번호 패턴: [0001], [0002], ... 또는 【0001】, 【0002】, ... (4~5자리)
            const paraNumPattern = /^\[(\d{4,5})\]\s*/;
            const paraNumPatternAlt = /^【(\d{4,5})】\s*/;
            
            // 단락번호 추출 함수
            function extractParaNum(line) {
                let match = line.match(paraNumPattern);
                if (match) return match[1];
                match = line.match(paraNumPatternAlt);
                if (match) return match[1];
                return null;
            }
            
            // 단락번호 제거 함수
            function removeParaNum(line) {
                return line.replace(paraNumPattern, '').replace(paraNumPatternAlt, '');
            }
            
            // 사무소표준US 메인 부제 목록 (섹션 구분용)
            const mainSectionHeaders = [
                { key: 'title', patterns: ['TITLE OF THE INVENTION', '【발명의 명칭】'] },
                { key: 'crossref', patterns: ['CROSS-REFERENCE TO RELATED APPLICATIONS', 'CROSS-REFERENCE TO RELATED APPLICATION'] },
                { key: 'background', patterns: ['BACKGROUND OF THE INVENTION', '【기술분야】', '【배경기술】'] },
                { key: 'summary', patterns: ['SUMMARY OF THE INVENTION', '【발명의 내용】'] },
                { key: 'drawings', patterns: ['BRIEF DESCRIPTION OF THE DRAWINGS', '【도면의 간단한 설명】'] },
                { key: 'detailed', patterns: ['DETAILED DESCRIPTION OF THE EMBODIMENTS', 'DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS', '【발명을 실시하기 위한 구체적인 내용】', '【발명의 실시를 위한 형태】'] },
                { key: 'symbols', patterns: ['Description of Symbols', 'DESCRIPTION OF SYMBOLS', '【부호의 설명】'] },
                { key: 'claims', patterns: ['WHAT IS CLAIMED IS:', 'WHAT IS CLAIMED IS', '【청구범위】', '【청구의 범위】'] },
                { key: 'abstract', patterns: ['ABSTRACT OF DISCLOSURE', 'ABSTRACT', '【요약서】', '【요약】'] }
            ];
            
            // 소부제 패턴 (섹션 내부에서 사용)
            const subSectionHeaders = [
                '(a) Field of the Invention',
                '(b) Description of the Related Art',
                '【해결하고자 하는 과제】',
                '【기술적 과제】',
                '【과제의 해결 수단】',
                '【기술적 해결방법】',
                '【발명의 효과】',
                'Description of Symbols',
                'DESCRIPTION OF SYMBOLS',
                '<Description of Symbols>',
                '<Description of symbols>',
                '<DESCRIPTION OF SYMBOLS>',
                '【부호의 설명】',
                '부호의 설명'
            ];
            
            // 메인 섹션 헤더인지 확인
            function getMainSectionKey(line) {
                const trimmed = removeParaNum(line).trim();
                for (const section of mainSectionHeaders) {
                    for (const pattern of section.patterns) {
                        if (trimmed.toUpperCase() === pattern.toUpperCase()) {
                            return section.key;
                        }
                    }
                }
                return null;
            }
            
            // 소부제인지 확인
            function isSubSectionHeader(line) {
                const trimmed = removeParaNum(line).trim();
                return subSectionHeaders.some(h => trimmed === h || trimmed.toUpperCase() === h.toUpperCase());
            }
            
            // 부제(메인 또는 소부제)인지 확인
            function isAnySubtitle(line) {
                const trimmed = removeParaNum(line).trim();
                if (!trimmed) return false;
                if (getMainSectionKey(line)) return true;
                if (isSubSectionHeader(line)) return true;
                return false;
            }
            
            // 본문 단락인지 확인 (마침표로 끝나거나 단락번호가 있음)
            function isContentParagraph(line) {
                const trimmed = removeParaNum(line).trim();
                if (!trimmed) return false;
                // 부제가 아니면 본문
                if (isAnySubtitle(line)) return false;
                return true;
            }
            
            // 청구항 시작 패턴 감지
            function isClaimStart(line) {
                const trimmed = removeParaNum(line).trim();
                if (/^\d+\.\s/.test(trimmed)) return true;
                if (/^【청구항\s*\d+】/.test(trimmed)) return true;
                if (/^【Claim\s*\d+】/i.test(trimmed)) return true;
                return false;
            }
            
            // 문서를 메인 섹션별로 분리
            function splitByMainSections(lines) {
                const sections = [];
                let currentSection = { key: null, header: null, lines: [] };
                
                for (const line of lines) {
                    const sectionKey = getMainSectionKey(line);
                    if (sectionKey) {
                        // 새 섹션 시작
                        if (currentSection.key || currentSection.lines.length > 0) {
                            sections.push(currentSection);
                        }
                        currentSection = { 
                            key: sectionKey, 
                            header: removeParaNum(line).trim(), 
                            lines: [] 
                        };
                    } else {
                        currentSection.lines.push(line);
                    }
                }
                
                if (currentSection.key || currentSection.lines.length > 0) {
                    sections.push(currentSection);
                }
                
                return sections;
            }
            
            // 섹션 분리
            const korSections = splitByMainSections(korLines);
            const engSections = splitByMainSections(engLines);
            
            // 섹션 키로 매핑
            const korSectionMap = new Map();
            korSections.forEach(s => {
                if (s.key) {
                    korSectionMap.set(s.key, s);
                }
            });
            
            const engSectionMap = new Map();
            engSections.forEach(s => {
                if (s.key) {
                    engSectionMap.set(s.key, s);
                }
            });
            
            // 부제 비교
            const korKeys = Array.from(korSectionMap.keys());
            const engKeys = Array.from(engSectionMap.keys());
            const allKeys = [...new Set([...korKeys, ...engKeys])];
            const mismatches = [];
            
            for (const key of allKeys) {
                const korHas = korKeys.includes(key);
                const engHas = engKeys.includes(key);
                
                if (korHas && !engHas) {
                    const korSection = korSectionMap.get(key);
                    mismatches.push({ key, type: 'kor_only', kor: korSection.header, eng: null });
                } else if (!korHas && engHas) {
                    const engSection = engSectionMap.get(key);
                    mismatches.push({ key, type: 'eng_only', kor: null, eng: engSection.header });
                }
            }
            
            let resultLines = [];
            let resultHtml = '';
            mergeResultPairs = [];
            
            // 경고 메시지 추가
            if (mismatches.length > 0) {
                resultHtml += `<div style="background:#fff3cd;padding:12px;margin:8px 0;border-radius:4px;border-left:4px solid #ffc107;">
                    <strong>⚠️ 부제 불일치 감지!</strong> 병합 전에 부제표준화를 권장합니다.<br>`;
                mismatches.forEach(m => {
                    if (m.type === 'kor_only') {
                        resultHtml += `<span style="color:#d63384;">국문에만 존재: ${m.kor}</span><br>`;
                    } else if (m.type === 'eng_only') {
                        resultHtml += `<span style="color:#0d6efd;">영문에만 존재: ${m.eng}</span><br>`;
                    }
                });
                resultHtml += `</div>`;
            }
            
            // 단락 추가 헬퍼 함수
            function addKorLine(line) {
                resultLines.push(line);
                mergeResultPairs.push({ text: line, type: 'kor' });
                resultHtml += `<div style="background:#e8f5e9;padding:8px 12px;margin:4px 0;border-radius:4px;border-left:3px solid #4caf50;">${escapeHtml(line)}</div>`;
            }
            
            function addEngLine(line) {
                resultLines.push(line);
                mergeResultPairs.push({ text: line, type: 'eng' });
                resultHtml += `<div style="background:#e3f2fd;padding:8px 12px;margin:4px 0;border-radius:4px;border-left:3px solid #2196f3;">${escapeHtml(line)}</div>`;
            }
            
            // 섹션 내용 병합 함수
            function mergeSectionContent(korSection, engSection, sectionKey) {
                // 국문 부제 출력 (있는 경우)
                if (korSection && korSection.header) {
                    addKorLine(korSection.header);
                } else if (engSection && engSection.header && !korSection) {
                    // 국문에 없고 영문만 있으면 영문 부제도 출력
                    addEngLine(engSection.header);
                }
                
                const korParas = korSection ? korSection.lines : [];
                const engParas = engSection ? engSection.lines : [];
                
                // 청구항 섹션은 특별 처리
                if (sectionKey === 'claims') {
                    function groupClaims(paragraphs) {
                        const claims = [];
                        let currentClaim = [];
                        
                        for (const line of paragraphs) {
                            if (isClaimStart(line)) {
                                if (currentClaim.length > 0) {
                                    claims.push(currentClaim);
                                }
                                currentClaim = [line];
                            } else {
                                currentClaim.push(line);
                            }
                        }
                        if (currentClaim.length > 0) {
                            claims.push(currentClaim);
                        }
                        return claims;
                    }
                    
                    const korClaims = groupClaims(korParas);
                    const engClaims = groupClaims(engParas);
                    
                    const maxClaimCount = Math.max(korClaims.length, engClaims.length);
                    for (let i = 0; i < maxClaimCount; i++) {
                        if (i < korClaims.length) {
                            korClaims[i].forEach(line => addKorLine(line));
                        }
                        if (i < engClaims.length) {
                            engClaims[i].forEach(line => addEngLine(removeParaNum(line)));
                        }
                    }
                    return;
                }
                
                // 영문에서 본문 단락만 추출 (부제 제외)
                const engContentParas = engParas.filter(line => isContentParagraph(line));
                
                // 단락번호 기반 매칭 준비
                const engByNum = new Map();
                const engNoNum = [];
                engContentParas.forEach(line => {
                    const num = extractParaNum(line);
                    if (num) {
                        if (!engByNum.has(num)) engByNum.set(num, []);
                        engByNum.get(num).push(line);
                    } else {
                        engNoNum.push(line);
                    }
                });
                
                let engNoNumIdx = 0;
                const usedEngNums = new Set();
                
                // 국문 라인을 순서대로 처리
                for (const korLine of korParas) {
                    // 국문 라인 출력 (부제든 본문이든 모두 출력)
                    addKorLine(korLine);
                    
                    // 본문 단락이면 대응하는 영문 찾기
                    if (isContentParagraph(korLine)) {
                        const korNum = extractParaNum(korLine);
                        
                        if (korNum && engByNum.has(korNum) && !usedEngNums.has(korNum)) {
                            // 단락번호 기반 매칭
                            const engLinesForNum = engByNum.get(korNum);
                            engLinesForNum.forEach(line => addEngLine(removeParaNum(line)));
                            usedEngNums.add(korNum);
                        } else if (!korNum && engNoNumIdx < engNoNum.length) {
                            // 단락번호 없는 경우 순서 매칭
                            addEngLine(removeParaNum(engNoNum[engNoNumIdx]));
                            engNoNumIdx++;
                        } else if (korNum) {
                            // 단락번호가 있지만 영문에 해당 번호가 없으면 순서 매칭 시도
                            if (engNoNumIdx < engNoNum.length) {
                                addEngLine(removeParaNum(engNoNum[engNoNumIdx]));
                                engNoNumIdx++;
                            }
                        }
                    }
                }
                
                // 남은 영문 단락 출력 (매칭되지 않은 것들)
                engByNum.forEach((lines, num) => {
                    if (!usedEngNums.has(num)) {
                        lines.forEach(line => addEngLine(removeParaNum(line)));
                    }
                });
                while (engNoNumIdx < engNoNum.length) {
                    addEngLine(removeParaNum(engNoNum[engNoNumIdx]));
                    engNoNumIdx++;
                }
            }
            
            // 섹션 없는 앞부분 처리 (있는 경우)
            const korNoSection = korSections.find(s => !s.key);
            const engNoSection = engSections.find(s => !s.key);
            if (korNoSection || engNoSection) {
                mergeSectionContent(korNoSection, engNoSection, null);
            }
            
            // 사무소표준US 순서대로 섹션 병합
            const sectionOrder = ['title', 'crossref', 'background', 'summary', 'drawings', 'detailed', 'symbols', 'claims', 'abstract'];
            
            for (const sectionKey of sectionOrder) {
                const korSection = korSectionMap.get(sectionKey);
                const engSection = engSectionMap.get(sectionKey);
                
                if (!korSection && !engSection) continue;
                
                mergeSectionContent(korSection, engSection, sectionKey);
            }
            
            mergeResult = resultLines.join('\n');
            
            // 통계 업데이트
            document.getElementById('mergeKorCount').textContent = korLines.length;
            document.getElementById('mergeEngCount').textContent = engLines.length;
            document.getElementById('mergeTotalCount').textContent = resultLines.length;
            document.getElementById('merge3StatsSection').classList.remove('hidden');
            
            // 결과 표시
            document.getElementById('mergeResult3').innerHTML = resultHtml;
            document.getElementById('merge3ResultSection').classList.remove('hidden');
            
            // 메시지
            if (mismatches.length > 0) {
                msg.textContent = `⚠️ 병합 완료! (부제 ${mismatches.length}개 불일치 - 부제표준화 권장)`;
                msg.className = 'message error';
            } else {
                msg.textContent = '✅ 병합 완료! (사무소표준US 기준, 부제 일치)';
                msg.className = 'message success';
            }
        }
        
        // escapeHtml은 utils.js에서 로드됨
        
        // 결과 복사
        function copyMergeResult3() {
            if (!mergeResult) {
                alert('병합 결과가 없습니다.');
                return;
            }
            navigator.clipboard.writeText(mergeResult).then(() => {
                alert('✅ 한영혼합본이 클립보드에 복사되었습니다.');
            });
        }
        
        // DOCX 다운로드
        async function downloadMergeDocx3() {
            if (!mergeResult || mergeResultPairs.length === 0) {
                alert('병합 결과가 없습니다.');
                return;
            }
            
            try {
                const zip = new JSZip();
                
                // [Content_Types].xml
                zip.file('[Content_Types].xml', `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
<Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
<Default Extension="xml" ContentType="application/xml"/>
<Override PartName="/word/document.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml"/>
</Types>`);
                
                // _rels/.rels
                zip.file('_rels/.rels', `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="word/document.xml"/>
</Relationships>`);
                
                // word/_rels/document.xml.rels
                zip.file('word/_rels/document.xml.rels', `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
</Relationships>`);
                
                // word/document.xml 생성 (mergeResultPairs 사용)
                let bodyContent = '';
                
                mergeResultPairs.forEach(item => {
                    const fillColor = item.type === 'kor' ? 'E8F5E9' : 'E3F2FD'; // 녹색 vs 파란색
                    bodyContent += `<w:p>
<w:pPr><w:shd w:val="clear" w:color="auto" w:fill="${fillColor}"/></w:pPr>
<w:r><w:t xml:space="preserve">${escapeXml(item.text)}</w:t></w:r>
</w:p>`;
                });
                
                const documentXml = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:document xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main">
<w:body>
${bodyContent}
<w:sectPr><w:pgSz w:w="12240" w:h="15840"/><w:pgMar w:top="1440" w:right="1440" w:bottom="1440" w:left="1440"/></w:sectPr>
</w:body>
</w:document>`;
                
                zip.file('word/document.xml', documentXml);
                
                const fileName = document.getElementById('mergeFileName3').value.trim() || '한영혼합본';
                const blob = await zip.generateAsync({ type: 'blob', mimeType: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' });
                saveAs(blob, fileName + '.docx');
                
            } catch (error) {
                alert('오류: ' + error.message);
            }
        }
        
        // 병합 탭 초기화
        function clearMerge3() {
            if (!confirm('모든 내용을 지우시겠습니까?')) return;
            document.getElementById('inputTextKor3').value = '';
            document.getElementById('inputTextEng3').value = '';
            document.getElementById('fileNameKor3').textContent = '국문명세서 .docx 파일을 선택하세요';
            document.getElementById('fileNameEng3').textContent = '영문명세서 .docx 파일을 선택하세요';
            document.getElementById('mergeFileName3').value = '';
            document.getElementById('mergeResult3').innerHTML = '한영혼합본이 여기에 표시됩니다';
            document.getElementById('merge3StatsSection').classList.add('hidden');
            document.getElementById('merge3ResultSection').classList.add('hidden');
            document.getElementById('merge3Message').classList.add('hidden');
            mergeKorParagraphs = [];
            mergeEngParagraphs = [];
            mergeResult = '';
            mergeResultPairs = [];
        }
        
        // 탭4 - 문서 비교
        
        // 탭4 - 워드 파일에서 텍스트 추출 (번호 매기기 포함)
        async function extractTextFromDocx4(file) {
            const zip = await JSZip.loadAsync(await file.arrayBuffer());
            const xml = await zip.file('word/document.xml').async('string');
            const doc = new DOMParser().parseFromString(xml, 'application/xml');
            
            // numbering.xml 파싱
            let numberingDefs = {};
            const numberingFile = zip.file('word/numbering.xml');
            if (numberingFile) {
                const numXml = await numberingFile.async('string');
                const numDoc = new DOMParser().parseFromString(numXml, 'application/xml');
                
                // abstractNum 정의 읽기
                const abstractNums = {};
                for (const abs of numDoc.getElementsByTagName('w:abstractNum')) {
                    const absId = abs.getAttribute('w:abstractNumId');
                    abstractNums[absId] = {};
                    for (const lvl of abs.getElementsByTagName('w:lvl')) {
                        const ilvl = lvl.getAttribute('w:ilvl');
                        const numFmt = lvl.getElementsByTagName('w:numFmt')[0]?.getAttribute('w:val') || 'decimal';
                        const lvlText = lvl.getElementsByTagName('w:lvlText')[0]?.getAttribute('w:val') || '%1.';
                        const start = parseInt(lvl.getElementsByTagName('w:start')[0]?.getAttribute('w:val') || '1');
                        abstractNums[absId][ilvl] = { numFmt, lvlText, start, counter: start };
                    }
                }
                
                // num -> abstractNum 매핑
                for (const num of numDoc.getElementsByTagName('w:num')) {
                    const numId = num.getAttribute('w:numId');
                    const absIdRef = num.getElementsByTagName('w:abstractNumId')[0]?.getAttribute('w:val');
                    if (absIdRef && abstractNums[absIdRef]) {
                        numberingDefs[numId] = {};
                        for (const ilvl in abstractNums[absIdRef]) {
                            numberingDefs[numId][ilvl] = { ...abstractNums[absIdRef][ilvl] };
                        }
                    }
                }
            }
            
            // 번호 포맷팅 함수
            function formatNumber(num, fmt) {
                if (fmt === 'decimal') return num.toString();
                if (fmt === 'decimalZero') return num.toString().padStart(2, '0'); // 01, 02, ..., 10, 11, ...
                if (fmt === 'lowerLetter') return String.fromCharCode(96 + ((num - 1) % 26) + 1);
                if (fmt === 'upperLetter') return String.fromCharCode(64 + ((num - 1) % 26) + 1);
                if (fmt === 'lowerRoman') return toRoman(num).toLowerCase();
                if (fmt === 'upperRoman') return toRoman(num);
                if (fmt === 'koreanCounting') return num.toString();
                return num.toString();
            }
            function toRoman(num) {
                const roman = {M:1000,CM:900,D:500,CD:400,C:100,XC:90,L:50,XL:40,X:10,IX:9,V:5,IV:4,I:1};
                let str = '';
                for (let i of Object.keys(roman)) {
                    let q = Math.floor(num / roman[i]);
                    num -= q * roman[i];
                    str += i.repeat(q);
                }
                return str;
            }
            
            const paras = [];
            for (const p of doc.getElementsByTagName('w:p')) {
                let text = '';
                
                // 단락 번호 처리
                const pPr = p.getElementsByTagName('w:pPr')[0];
                const numPr = pPr?.getElementsByTagName('w:numPr')[0];
                if (numPr) {
                    const numId = numPr.getElementsByTagName('w:numId')[0]?.getAttribute('w:val');
                    const ilvl = numPr.getElementsByTagName('w:ilvl')[0]?.getAttribute('w:val') || '0';
                    if (numId && numberingDefs[numId] && numberingDefs[numId][ilvl]) {
                        const lvlDef = numberingDefs[numId][ilvl];
                        const formattedNum = formatNumber(lvlDef.counter, lvlDef.numFmt);
                        // lvlText 패턴 적용 (예: "%1.", "%1)", "(%1)" 등)
                        let numText = lvlDef.lvlText.replace(/%\d+/g, formattedNum);
                        text = numText + ' ';
                        lvlDef.counter++;
                    }
                }
                
                for (const r of p.getElementsByTagName('w:r')) {
                    for (const t of r.getElementsByTagName('w:t')) {
                        text += t.textContent || '';
                    }
                }
                paras.push(text);
            }
            return paras.join('\n');
        }
        
        // 텍스트 정규화 함수 (포맷 무시를 위해)
        function normalizeText(text) {
            return text
                .replace(/\r\n/g, '\n')           // 줄바꿈 통일
                .replace(/\r/g, '\n')             // 줄바꿈 통일
                .replace(/\t/g, ' ')              // 탭을 공백으로
                .replace(/ +/g, ' ')              // 연속 공백을 하나로
                .trim();                          // 앞뒤 공백 제거
        }
        
        // 라인 정규화 함수 (비교용)
        function normalizeLine(line) {
            return line
                .replace(/^\s*\[\d+\]\s*/g, '')   // 단락번호 [0001], [00100] 등 모든 자리수 제거
                .replace(/\t/g, ' ')              // 탭을 공백으로
                .replace(/ +/g, ' ')              // 연속 공백을 하나로
                .trim();                          // 앞뒤 공백 제거
        }
        
        // 탭4 - 파일 처리 함수 (문서1)
        async function handleFile4a(file) {
            if (!file) return;
            if (!file.name.toLowerCase().endsWith('.docx')) {
                alert('❌ .docx 파일만 업로드 가능합니다.');
                return;
            }
            document.getElementById('fileName4a').textContent = file.name;
            try {
                const text = await extractTextFromDocx4(file);
                document.getElementById('inputText4a').value = text;
            } catch (error) { 
                alert('오류: ' + error.message); 
            }
        }
        
        // 탭4 - 파일 처리 함수 (문서2)
        async function handleFile4b(file) {
            if (!file) return;
            if (!file.name.toLowerCase().endsWith('.docx')) {
                alert('❌ .docx 파일만 업로드 가능합니다.');
                return;
            }
            document.getElementById('fileName4b').textContent = file.name;
            try {
                const text = await extractTextFromDocx4(file);
                document.getElementById('inputText4b').value = text;
            } catch (error) { 
                alert('오류: ' + error.message); 
            }
        }
        
        // 탭4 - 파일 선택 이벤트
        document.getElementById('fileInput4a').addEventListener('change', async function(e) {
            await handleFile4a(e.target.files[0]);
        });
        document.getElementById('fileInput4b').addEventListener('change', async function(e) {
            await handleFile4b(e.target.files[0]);
        });
        
        // 탭4 - 드래그 앤 드롭 (문서1)
        const inputText4a = document.getElementById('inputText4a');
        inputText4a.addEventListener('dragover', function(e) {
            e.preventDefault();
            e.stopPropagation();
            this.classList.add('drag-over');
        });
        inputText4a.addEventListener('dragleave', function(e) {
            e.preventDefault();
            e.stopPropagation();
            this.classList.remove('drag-over');
        });
        inputText4a.addEventListener('drop', async function(e) {
            e.preventDefault();
            e.stopPropagation();
            this.classList.remove('drag-over');
            if (e.dataTransfer.files.length > 0) {
                await handleFile4a(e.dataTransfer.files[0]);
            }
        });
        
        // 탭4 - 드래그 앤 드롭 (문서2)
        const inputText4b = document.getElementById('inputText4b');
        inputText4b.addEventListener('dragover', function(e) {
            e.preventDefault();
            e.stopPropagation();
            this.classList.add('drag-over');
        });
        inputText4b.addEventListener('dragleave', function(e) {
            e.preventDefault();
            e.stopPropagation();
            this.classList.remove('drag-over');
        });
        inputText4b.addEventListener('drop', async function(e) {
            e.preventDefault();
            e.stopPropagation();
            this.classList.remove('drag-over');
            if (e.dataTransfer.files.length > 0) {
                await handleFile4b(e.dataTransfer.files[0]);
            }
        });
        
        // Diff 알고리즘 함수는 utils.js에서 로드됨
        
        function getDiff(a, b) {
            const dp = computeLCS(a, b);
            const result = [];
            let i = a.length, j = b.length;
            
            while (i > 0 || j > 0) {
                if (i > 0 && j > 0 && a[i-1] === b[j-1]) {
                    result.unshift({ type: 'same', lineA: i, lineB: j, textA: a[i-1], textB: b[j-1] });
                    i--; j--;
                } else if (j > 0 && (i === 0 || dp[i][j-1] >= dp[i-1][j])) {
                    result.unshift({ type: 'added', lineA: null, lineB: j, textA: null, textB: b[j-1] });
                    j--;
                } else if (i > 0) {
                    result.unshift({ type: 'deleted', lineA: i, lineB: null, textA: a[i-1], textB: null });
                    i--;
                }
            }
            
            // 인접한 deleted-added 쌍만 modified로 병합 (엄격한 조건)
            const merged = [];
            let k = 0;
            
            while (k < result.length) {
                const current = result[k];
                const next = k + 1 < result.length ? result[k + 1] : null;
                
                // deleted 바로 다음에 added가 오는 경우만 modified로 병합
                if (current.type === 'deleted' && next && next.type === 'added') {
                    merged.push({
                        type: 'modified',
                        lineA: current.lineA,
                        lineB: next.lineB,
                        textA: current.textA,
                        textB: next.textB
                    });
                    k += 2;
                }
                // added 바로 다음에 deleted가 오는 경우도 modified로 병합
                else if (current.type === 'added' && next && next.type === 'deleted') {
                    merged.push({
                        type: 'modified',
                        lineA: next.lineA,
                        lineB: current.lineB,
                        textA: next.textA,
                        textB: current.textB
                    });
                    k += 2;
                }
                else {
                    merged.push(current);
                    k++;
                }
            }
            
            return merged;
        }
        
        function compareDocuments() {
            const textA = document.getElementById('inputText4a').value;
            const textB = document.getElementById('inputText4b').value;
            
            if (!textA.trim() || !textB.trim()) {
                alert('두 문서 모두 입력해주세요.');
                return;
            }
            
            // 줄바꿈 통일 후 라인 분리
            const unifiedTextA = textA.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
            const unifiedTextB = textB.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
            
            // 원본 라인
            const allLinesA = unifiedTextA.split('\n');
            const allLinesB = unifiedTextB.split('\n');
            
            // 빈줄 제외한 라인과 원본 인덱스 추출
            const nonEmptyA = [];
            const nonEmptyB = [];
            
            allLinesA.forEach((line, idx) => {
                const normalized = normalizeLine(line);
                if (normalized) {  // 빈줄이 아닌 경우만
                    nonEmptyA.push({ text: normalized, origIdx: idx, origText: line });
                }
            });
            
            allLinesB.forEach((line, idx) => {
                const normalized = normalizeLine(line);
                if (normalized) {  // 빈줄이 아닌 경우만
                    nonEmptyB.push({ text: normalized, origIdx: idx, origText: line });
                }
            });
            
            // 비교용 텍스트 배열
            const linesA = nonEmptyA.map(item => item.text);
            const linesB = nonEmptyB.map(item => item.text);
            
            const diff = getDiff(linesA, linesB);
            
            // 통계 계산
            let sameCount = 0, modifiedCount = 0, addedCount = 0, deletedCount = 0;
            diff.forEach(d => {
                if (d.type === 'same') sameCount++;
                else if (d.type === 'modified') modifiedCount++;
                else if (d.type === 'added') addedCount++;
                else if (d.type === 'deleted') deletedCount++;
            });
            
            document.getElementById('totalLines4').textContent = Math.max(nonEmptyA.length, nonEmptyB.length);
            document.getElementById('sameLines4').textContent = sameCount;
            document.getElementById('modifiedLines4').textContent = modifiedCount;
            document.getElementById('addedLines4').textContent = addedCount;
            document.getElementById('deletedLines4').textContent = deletedCount;
            
            // 결과 표시 (원본 텍스트 사용)
            let htmlA = '', htmlB = '';
            diff.forEach(d => {
                const escapeHtml = (t) => t ? t.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;') : '';
                
                // 원본 라인 가져오기 (diff의 lineA/lineB는 1-based index) - 안전한 접근
                const itemA = (d.lineA && d.lineA > 0 && d.lineA <= nonEmptyA.length) ? nonEmptyA[d.lineA - 1] : null;
                const itemB = (d.lineB && d.lineB > 0 && d.lineB <= nonEmptyB.length) ? nonEmptyB[d.lineB - 1] : null;
                
                // 원본 텍스트 가져오기 - 여러 소스에서 폴백
                let origTextA = '';
                if (itemA && itemA.origText) {
                    origTextA = itemA.origText;
                } else if (d.textA) {
                    origTextA = d.textA;
                }
                
                let origTextB = '';
                if (itemB && itemB.origText) {
                    origTextB = itemB.origText;
                } else if (d.textB) {
                    origTextB = d.textB;
                }
                
                const origLineNumA = itemA ? (itemA.origIdx + 1) : (d.lineA || '-');
                const origLineNumB = itemB ? (itemB.origIdx + 1) : (d.lineB || '-');
                
                if (d.type === 'same') {
                    htmlA += `<div class="compare-line same"><span class="compare-line-num">${origLineNumA}</span>${escapeHtml(origTextA)}</div>`;
                    htmlB += `<div class="compare-line same"><span class="compare-line-num">${origLineNumB}</span>${escapeHtml(origTextB)}</div>`;
                } else if (d.type === 'modified') {
                    // 원본 텍스트를 기본값으로 설정
                    const escapedA = escapeHtml(origTextA);
                    const escapedB = escapeHtml(origTextB);
                    
                    // 단어 단위 비교하여 하이라이트 적용
                    const highlighted = highlightModifiedLine(origTextA, origTextB);
                    
                    // 결과가 유효하면 사용, 아니면 원본 텍스트 사용
                    const finalHtmlA = (highlighted && highlighted.htmlA) ? highlighted.htmlA : escapedA;
                    const finalHtmlB = (highlighted && highlighted.htmlB) ? highlighted.htmlB : escapedB;
                    
                    htmlA += `<div class="compare-line modified"><span class="compare-line-num">${origLineNumA}</span>${finalHtmlA}</div>`;
                    htmlB += `<div class="compare-line modified"><span class="compare-line-num">${origLineNumB}</span>${finalHtmlB}</div>`;
                } else if (d.type === 'added') {
                    // 추가된 라인: 문서A에 빈 자리 표시, 문서B에 추가된 내용
                    htmlA += `<div class="compare-line added-placeholder"><span class="compare-line-num">-</span><span style="color:#155724;font-style:italic;">(추가된 내용)</span></div>`;
                    htmlB += `<div class="compare-line added"><span class="compare-line-num">${origLineNumB}</span>${escapeHtml(origTextB) || '(내용 없음)'}</div>`;
                } else if (d.type === 'deleted') {
                    // 삭제된 라인: 문서A에 삭제된 내용, 문서B에 빈 자리 표시
                    htmlA += `<div class="compare-line deleted"><span class="compare-line-num">${origLineNumA}</span>${escapeHtml(origTextA) || '(내용 없음)'}</div>`;
                    htmlB += `<div class="compare-line deleted-placeholder"><span class="compare-line-num">-</span><span style="color:#721c24;font-style:italic;">(삭제된 내용)</span></div>`;
                }
            });
            
            document.getElementById('compareResult4a').innerHTML = htmlA;
            document.getElementById('compareResult4b').innerHTML = htmlB;
            document.getElementById('compare4Section').classList.remove('hidden');
            
            // 스크롤 동기화
            const panelA = document.getElementById('compareResult4a');
            const panelB = document.getElementById('compareResult4b');
            panelA.onscroll = function() { panelB.scrollTop = panelA.scrollTop; };
            panelB.onscroll = function() { panelA.scrollTop = panelB.scrollTop; };
        }
        
        function clearAll4() {
            if (!confirm('모든 내용을 지우시겠습니까?')) return;
            document.getElementById('inputText4a').value = '';
            document.getElementById('inputText4b').value = '';
            document.getElementById('fileName4a').textContent = '또는 아래에 .docx 파일을 드래그하세요';
            document.getElementById('fileName4b').textContent = '또는 아래에 .docx 파일을 드래그하세요';
            document.getElementById('compareResult4a').innerHTML = '';
            document.getElementById('compareResult4b').innerHTML = '';
            document.getElementById('compare4Section').classList.add('hidden');
        }
        
        // 서브탭 전환 함수
        function switchSubTab4(tabType, btn) {
            document.querySelectorAll('#tab4 .sub-tab-btn').forEach(b => b.classList.remove('active'));
            document.querySelectorAll('#tab4 .sub-tab-content').forEach(c => c.classList.remove('active'));
            btn.classList.add('active');
            if (tabType === 'text') {
                document.getElementById('subTab4Text').classList.add('active');
            } else {
                document.getElementById('subTab4Docx').classList.add('active');
            }
        }
        
        // ========== DOCX 비교 기능 ==========
        let docxFileA = null;
        let docxFileB = null;
        let docxDataA = null;
        let docxDataB = null;
        
        // DOCX 파일에서 텍스트 추출 (단락별)
        async function extractParagraphsFromDocx(file) {
            const zip = await JSZip.loadAsync(await file.arrayBuffer());
            const xml = await zip.file('word/document.xml').async('string');
            const doc = new DOMParser().parseFromString(xml, 'application/xml');
            const paragraphs = [];
            
            for (const p of doc.getElementsByTagName('w:p')) {
                let text = '';
                for (const r of p.getElementsByTagName('w:r')) {
                    for (const t of r.getElementsByTagName('w:t')) {
                        text += t.textContent || '';
                    }
                }
                paragraphs.push(text);
            }
            return { paragraphs, zip, xml };
        }
        
        // DOCX 파일 처리 (원본)
        async function handleDocxFile4a(file) {
            if (!file) return;
            if (!file.name.toLowerCase().endsWith('.docx')) {
                alert('❌ .docx 파일만 업로드 가능합니다.');
                return;
            }
            docxFileA = file;
            document.getElementById('fileNameDocx4a').textContent = file.name;
            try {
                docxDataA = await extractParagraphsFromDocx(file);
                const preview = docxDataA.paragraphs.filter(p => p.trim()).slice(0, 10).join('\n');
                document.getElementById('docxPreview4a').value = preview + (docxDataA.paragraphs.length > 10 ? '\n...' : '');
            } catch (error) {
                alert('오류: ' + error.message);
            }
        }
        
        // DOCX 파일 처리 (수정본)
        async function handleDocxFile4b(file) {
            if (!file) return;
            if (!file.name.toLowerCase().endsWith('.docx')) {
                alert('❌ .docx 파일만 업로드 가능합니다.');
                return;
            }
            docxFileB = file;
            document.getElementById('fileNameDocx4b').textContent = file.name;
            try {
                docxDataB = await extractParagraphsFromDocx(file);
                const preview = docxDataB.paragraphs.filter(p => p.trim()).slice(0, 10).join('\n');
                document.getElementById('docxPreview4b').value = preview + (docxDataB.paragraphs.length > 10 ? '\n...' : '');
            } catch (error) {
                alert('오류: ' + error.message);
            }
        }
        
        // 파일 선택 이벤트
        document.getElementById('fileInputDocx4a').addEventListener('change', async function(e) {
            await handleDocxFile4a(e.target.files[0]);
        });
        document.getElementById('fileInputDocx4b').addEventListener('change', async function(e) {
            await handleDocxFile4b(e.target.files[0]);
        });
        
        // 드래그 앤 드롭 이벤트 (원본)
        const docxPreview4a = document.getElementById('docxPreview4a');
        docxPreview4a.addEventListener('dragover', function(e) {
            e.preventDefault();
            e.stopPropagation();
            this.classList.add('drag-over');
        });
        docxPreview4a.addEventListener('dragleave', function(e) {
            e.preventDefault();
            e.stopPropagation();
            this.classList.remove('drag-over');
        });
        docxPreview4a.addEventListener('drop', async function(e) {
            e.preventDefault();
            e.stopPropagation();
            this.classList.remove('drag-over');
            if (e.dataTransfer.files.length > 0) {
                await handleDocxFile4a(e.dataTransfer.files[0]);
            }
        });
        docxPreview4a.addEventListener('click', function() {
            document.getElementById('fileInputDocx4a').click();
        });
        
        // 드래그 앤 드롭 이벤트 (수정본)
        const docxPreview4b = document.getElementById('docxPreview4b');
        docxPreview4b.addEventListener('dragover', function(e) {
            e.preventDefault();
            e.stopPropagation();
            this.classList.add('drag-over');
        });
        docxPreview4b.addEventListener('dragleave', function(e) {
            e.preventDefault();
            e.stopPropagation();
            this.classList.remove('drag-over');
        });
        docxPreview4b.addEventListener('drop', async function(e) {
            e.preventDefault();
            e.stopPropagation();
            this.classList.remove('drag-over');
            if (e.dataTransfer.files.length > 0) {
                await handleDocxFile4b(e.dataTransfer.files[0]);
            }
        });
        docxPreview4b.addEventListener('click', function() {
            document.getElementById('fileInputDocx4b').click();
        });
        
        // 단락 비교를 위한 개선된 알고리즘
        // calculateSimilarity, getWordDiffForDocx는 utils.js에서 로드됨
        
        // 순서 기반 단락 비교 알고리즘 (MS Word 스타일)
        function getParagraphDiffWithMatching(parasA, parasB) {
            const normA = parasA.map(p => p.trim()).filter(p => p);
            const normB = parasB.map(p => p.trim()).filter(p => p);
            
            const result = [];
            
            // LCS를 사용하여 단락 순서 매칭
            const m = normA.length;
            const n = normB.length;
            
            // DP 테이블 생성 (단락 단위 LCS)
            const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));
            
            // 유사도 캐시
            const simCache = {};
            const getSim = (i, j) => {
                const key = `${i}-${j}`;
                if (!(key in simCache)) {
                    simCache[key] = calculateSimilarity(normA[i], normB[j]);
                }
                return simCache[key];
            };
            
            // DP 채우기 - 유사도 15% 이상이면 매칭 가능
            for (let i = 1; i <= m; i++) {
                for (let j = 1; j <= n; j++) {
                    const sim = getSim(i - 1, j - 1);
                    if (sim >= 0.15 || normA[i-1] === normB[j-1]) {
                        dp[i][j] = dp[i-1][j-1] + 1;
                    } else {
                        dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);
                    }
                }
            }
            
            // Backtrack하여 매칭 결과 생성
            const matches = [];
            let i = m, j = n;
            while (i > 0 && j > 0) {
                const sim = getSim(i - 1, j - 1);
                if ((sim >= 0.15 || normA[i-1] === normB[j-1]) && dp[i][j] === dp[i-1][j-1] + 1) {
                    matches.unshift({ idxA: i - 1, idxB: j - 1, similarity: sim });
                    i--; j--;
                } else if (dp[i-1][j] >= dp[i][j-1]) {
                    i--;
                } else {
                    j--;
                }
            }
            
            // 매칭 결과를 기반으로 diff 생성
            let ptrA = 0, ptrB = 0;
            const usedA = new Set(matches.map(m => m.idxA));
            const usedB = new Set(matches.map(m => m.idxB));
            
            for (const match of matches) {
                // 매칭되기 전 A의 삭제된 단락들
                while (ptrA < match.idxA) {
                    if (!usedA.has(ptrA)) {
                        // 삭제된 단락과 인접한 추가 단락이 있으면 병합
                        let merged = false;
                        if (ptrB < match.idxB && !usedB.has(ptrB)) {
                            // 유사도 체크 후 병합
                            const mergeSim = calculateSimilarity(normA[ptrA], normB[ptrB]);
                            if (mergeSim >= 0.05) { // 매우 낮은 임계값 - 같은 위치면 병합
                                result.push({
                                    type: 'modified',
                                    textA: normA[ptrA],
                                    textB: normB[ptrB],
                                    wordDiff: getWordDiffForDocx(normA[ptrA], normB[ptrB])
                                });
                                ptrB++;
                                merged = true;
                            }
                        }
                        if (!merged) {
                            result.push({ type: 'deleted', textA: normA[ptrA] });
                        }
                    }
                    ptrA++;
                }
                
                // 매칭되기 전 B의 추가된 단락들
                while (ptrB < match.idxB) {
                    if (!usedB.has(ptrB)) {
                        result.push({ type: 'added', textB: normB[ptrB] });
                    }
                    ptrB++;
                }
                
                // 매칭된 단락 비교
                if (normA[match.idxA] === normB[match.idxB]) {
                    result.push({ type: 'same', textA: normA[match.idxA], textB: normB[match.idxB] });
                } else {
                    result.push({
                        type: 'modified',
                        textA: normA[match.idxA],
                        textB: normB[match.idxB],
                        wordDiff: getWordDiffForDocx(normA[match.idxA], normB[match.idxB])
                    });
                }
                ptrA = match.idxA + 1;
                ptrB = match.idxB + 1;
            }
            
            // 남은 단락들 처리 (삭제와 추가를 짝지어 병합 시도)
            const remainingA = [];
            const remainingB = [];
            
            while (ptrA < m) {
                if (!usedA.has(ptrA)) {
                    remainingA.push(ptrA);
                }
                ptrA++;
            }
            
            while (ptrB < n) {
                if (!usedB.has(ptrB)) {
                    remainingB.push(ptrB);
                }
                ptrB++;
            }
            
            // 남은 단락들을 순서대로 병합 또는 삭제/추가 처리
            const maxRemaining = Math.max(remainingA.length, remainingB.length);
            for (let k = 0; k < maxRemaining; k++) {
                const hasA = k < remainingA.length;
                const hasB = k < remainingB.length;
                
                if (hasA && hasB) {
                    const idxA = remainingA[k];
                    const idxB = remainingB[k];
                    const sim = calculateSimilarity(normA[idxA], normB[idxB]);
                    
                    if (sim >= 0.05) {
                        // 병합
                        result.push({
                            type: 'modified',
                            textA: normA[idxA],
                            textB: normB[idxB],
                            wordDiff: getWordDiffForDocx(normA[idxA], normB[idxB])
                        });
                    } else {
                        // 별도 처리
                        result.push({ type: 'deleted', textA: normA[idxA] });
                        result.push({ type: 'added', textB: normB[idxB] });
                    }
                } else if (hasA) {
                    result.push({ type: 'deleted', textA: normA[remainingA[k]] });
                } else if (hasB) {
                    result.push({ type: 'added', textB: normB[remainingB[k]] });
                }
            }
            
            return result;
        }
        
        // Track Changes가 적용된 DOCX 파일 생성 (단어 단위 비교 적용)
        async function compareDocxFiles() {
            const msg = document.getElementById('docxCompareMessage');
            msg.classList.add('hidden');
            
            if (!docxDataA || !docxDataB) {
                msg.textContent = '❌ 두 개의 DOCX 파일을 모두 업로드해주세요.';
                msg.className = 'message error';
                return;
            }
            
            try {
                const parasA = docxDataA.paragraphs;
                const parasB = docxDataB.paragraphs;
                
                // 개선된 diff 계산 (유사 단락 매칭 + 단어 단위 비교)
                const diff = getParagraphDiffWithMatching(parasA, parasB);
                
                // 통계 계산
                let sameCount = 0, modifiedCount = 0, addedCount = 0, deletedCount = 0;
                diff.forEach(d => {
                    if (d.type === 'same') sameCount++;
                    else if (d.type === 'modified') modifiedCount++;
                    else if (d.type === 'added') addedCount++;
                    else if (d.type === 'deleted') deletedCount++;
                });
                
                document.getElementById('docxTotalPara').textContent = diff.length;
                document.getElementById('docxSamePara').textContent = sameCount;
                document.getElementById('docxModifiedPara').textContent = modifiedCount;
                document.getElementById('docxAddedPara').textContent = addedCount;
                document.getElementById('docxDeletedPara').textContent = deletedCount;
                document.getElementById('docxCompareStats').classList.remove('hidden');
                
                // 현재 날짜/시간
                const now = new Date();
                const dateStr = now.toISOString().replace(/[-:]/g, '').split('.')[0] + 'Z';
                
                // Track Changes XML 생성
                let bodyContent = '';
                let revisionId = 1;
                
                diff.forEach(d => {
                    if (d.type === 'same') {
                        // 동일한 단락
                        bodyContent += `<w:p><w:r><w:t xml:space="preserve">${escapeXml(d.textA)}</w:t></w:r></w:p>`;
                    } else if (d.type === 'deleted') {
                        // 완전히 삭제된 단락
                        bodyContent += `<w:p><w:del w:id="${revisionId}" w:author="user" w:date="${dateStr}"><w:r><w:delText xml:space="preserve">${escapeXml(d.textA)}</w:delText></w:r></w:del></w:p>`;
                        revisionId++;
                    } else if (d.type === 'added') {
                        // 완전히 추가된 단락
                        bodyContent += `<w:p><w:ins w:id="${revisionId}" w:author="user" w:date="${dateStr}"><w:r><w:t xml:space="preserve">${escapeXml(d.textB)}</w:t></w:r></w:ins></w:p>`;
                        revisionId++;
                    } else if (d.type === 'modified') {
                        // 수정된 단락 - 단어 단위로 변경 표시
                        bodyContent += '<w:p>';
                        
                        const wordDiff = d.wordDiff;
                        
                        for (let idx = 0; idx < wordDiff.length; idx++) {
                            const wd = wordDiff[idx];
                            const nextWd = wordDiff[idx + 1];
                            const prevWd = wordDiff[idx - 1];
                            
                            // 단어 + 공백 조합
                            let wordText = wd.word;
                            
                            // 공백 처리:
                            // 1. same/added 타입은 원본 공백 사용
                            // 2. deleted 타입은 다음 단어가 added가 아니면 공백 추가
                            // 3. deleted→added 연속은 공백 없음 (대체)
                            if (wd.type === 'deleted') {
                                // 삭제된 단어 뒤에 추가된 단어가 바로 오면 공백 없음
                                if (!nextWd || nextWd.type !== 'added') {
                                    wordText += ' ';
                                }
                            } else {
                                // same 또는 added는 원본 공백 사용
                                wordText += wd.space || '';
                            }
                            
                            if (wd.type === 'same') {
                                bodyContent += `<w:r><w:t xml:space="preserve">${escapeXml(wordText)}</w:t></w:r>`;
                            } else if (wd.type === 'deleted') {
                                bodyContent += `<w:del w:id="${revisionId}" w:author="user" w:date="${dateStr}"><w:r><w:delText xml:space="preserve">${escapeXml(wordText)}</w:delText></w:r></w:del>`;
                                revisionId++;
                            } else if (wd.type === 'added') {
                                bodyContent += `<w:ins w:id="${revisionId}" w:author="user" w:date="${dateStr}"><w:r><w:t xml:space="preserve">${escapeXml(wordText)}</w:t></w:r></w:ins>`;
                                revisionId++;
                            }
                        }
                        
                        bodyContent += '</w:p>';
                    }
                });
                
                // 새 DOCX 파일 생성
                const newZip = new JSZip();
                
                // [Content_Types].xml
                newZip.file('[Content_Types].xml', `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
<Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
<Default Extension="xml" ContentType="application/xml"/>
<Override PartName="/word/document.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml"/>
<Override PartName="/word/settings.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml"/>
</Types>`);
                
                // _rels/.rels
                newZip.file('_rels/.rels', `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="word/document.xml"/>
</Relationships>`);
                
                // word/_rels/document.xml.rels
                newZip.file('word/_rels/document.xml.rels', `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/settings" Target="settings.xml"/>
</Relationships>`);
                
                // word/settings.xml (Track Changes 활성화, 서식 비교 제외)
                newZip.file('word/settings.xml', `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:settings xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main">
<w:trackRevisions/>
<w:revisionView w:formatting="0"/>
<w:defaultTabStop w:val="720"/>
<w:characterSpacingControl w:val="doNotCompress"/>
</w:settings>`);
                
                // word/document.xml
                const documentXml = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:document xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main">
<w:body>
${bodyContent}
<w:sectPr><w:pgSz w:w="12240" w:h="15840"/><w:pgMar w:top="1440" w:right="1440" w:bottom="1440" w:left="1440"/></w:sectPr>
</w:body>
</w:document>`;
                
                newZip.file('word/document.xml', documentXml);
                
                // DOCX 파일 생성 및 다운로드
                const fileName = document.getElementById('outputFileNameDocx4').value.trim() || '비교결과';
                const blob = await newZip.generateAsync({ type: 'blob', mimeType: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' });
                saveAs(blob, fileName + '.docx');
                
                msg.textContent = `✅ 비교 완료! ${fileName}.docx 파일이 다운로드됩니다. MS Word에서 '검토' 탭으로 변경 내용을 확인하세요.`;
                msg.className = 'message success';
                
            } catch (error) {
                msg.textContent = '❌ 오류: ' + error.message;
                msg.className = 'message error';
            }
        }
        
        // escapeXml은 utils.js에서 로드됨
        
        // DOCX 비교 탭 초기화
        function clearDocx4() {
            if (!confirm('모든 내용을 지우시겠습니까?')) return;
            docxFileA = null;
            docxFileB = null;
            docxDataA = null;
            docxDataB = null;
            document.getElementById('docxPreview4a').value = '';
            document.getElementById('docxPreview4b').value = '';
            document.getElementById('fileNameDocx4a').textContent = '원본 .docx 파일을 선택하세요';
            document.getElementById('fileNameDocx4b').textContent = '수정된 .docx 파일을 선택하세요';
            document.getElementById('outputFileNameDocx4').value = '';
            document.getElementById('docxCompareMessage').classList.add('hidden');
            document.getElementById('docxCompareStats').classList.add('hidden');
        }
        
        // ========== 탭5: Markdown to PDF ==========
        const mdInputText = document.getElementById('mdInputText');
        const mdPreviewContent = document.getElementById('mdPreviewContent');
        const mdPreviewPaper = document.getElementById('mdPreviewPaper');
        const mdFontSizeDisplay = document.getElementById('mdFontSizeDisplay');
        const mdOrientationSelect = document.getElementById('mdOrientationSelect');
        const mdPaperSizeLabel = document.getElementById('mdPaperSizeLabel');
        
        let mdCurrentFontSize = 12;
        let mdCurrentOrientation = 'portrait';
        const mdDefaultExampleText = mdInputText ? mdInputText.value : '';
        
        // 동적 스타일 시트 (인쇄 용지 방향 설정용)
        const mdStyleSheet = document.createElement("style");
        document.head.appendChild(mdStyleSheet);
        
        // Marked.js 옵션 - 볼드체 등 인라인 스타일 지원
        if (window.marked) {
            marked.setOptions({ 
                breaks: true, 
                gfm: true,
                pedantic: false,
                smartLists: true,
                smartypants: false
            });
        }
        
        // 렌더링 로직
        function renderMdMarkdown() {
            if (!mdInputText || !mdPreviewContent) return;
            
            let rawText = mdInputText.value;
            const mathBlocks = [];
            
            // 수식 보호 처리 (디스플레이 수식 먼저)
            rawText = rawText.replace(/\$\$([\s\S]+?)\$\$/g, (match) => {
                mathBlocks.push(match);
                return `%%%MATH_BLOCK_${mathBlocks.length - 1}%%%`;
            });
            // 인라인 수식 (단일 $ 사이의 내용, 줄바꿈 없음)
            // 볼드체 **와 충돌하지 않도록 $ 앞뒤가 *가 아닌 경우만 매칭
            rawText = rawText.replace(/([^*\$]|^)\$([^\$\n*]+?)\$([^*]|$)/g, (match, before, content, after) => {
                mathBlocks.push('$' + content + '$');
                return before + `%%%MATH_BLOCK_${mathBlocks.length - 1}%%%` + after;
            });
            
            // marked.js가 없을 경우 기본 마크다운 변환 (볼드, 이탤릭)
            let html;
            if (window.marked) {
                html = marked.parse(rawText, { breaks: true, gfm: true });
            } else {
                // Fallback: 기본적인 마크다운 변환
                html = rawText
                    .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')  // **볼드**
                    .replace(/__(.+?)__/g, '<strong>$1</strong>')      // __볼드__
                    .replace(/\*(.+?)\*/g, '<em>$1</em>')              // *이탤릭*
                    .replace(/_(.+?)_/g, '<em>$1</em>')                // _이탤릭_
                    .replace(/~~(.+?)~~/g, '<del>$1</del>')            // ~~취소선~~
                    .replace(/\n/g, '<br>');
            }
            
            // 수식 복구
            mathBlocks.forEach((block, index) => {
                const safeBlock = block.replace(/</g, '&lt;').replace(/>/g, '&gt;');
                html = html.replace(`%%%MATH_BLOCK_${index}%%%`, safeBlock);
            });
            
            mdPreviewContent.innerHTML = html;
            
            // KaTeX 렌더링
            if (window.renderMathInElement) {
                renderMathInElement(mdPreviewContent, {
                    delimiters: [
                        {left: '$$', right: '$$', display: true},
                        {left: '$', right: '$', display: false},
                        {left: '\\(', right: '\\)', display: false},
                        {left: '\\[', right: '\\]', display: true}
                    ],
                    throwOnError: false,
                    ignoredTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
                });
            }
        }
        
        // 초기 렌더링
        document.addEventListener("DOMContentLoaded", function() {
            renderMdMarkdown();
            changeMdOrientation();
        });
        
        if (mdInputText) {
            mdInputText.addEventListener('input', renderMdMarkdown);
            
            // 포커스 시 예제 삭제
            mdInputText.addEventListener('focus', function() {
                if (this.value === mdDefaultExampleText) {
                    this.value = '';
                    renderMdMarkdown();
                }
            });
            
            // 표 붙여넣기 기능
            mdInputText.addEventListener('paste', function(e) {
                const clipboardData = e.clipboardData || window.clipboardData;
                const pastedHTML = clipboardData.getData('text/html');
                
                if (pastedHTML && pastedHTML.includes('<table')) {
                    e.preventDefault();
                    const markdownTable = convertHtmlTableToMdMarkdown(pastedHTML);
                    const start = this.selectionStart;
                    const end = this.selectionEnd;
                    this.setRangeText(markdownTable, start, end, 'end');
                    renderMdMarkdown();
                    alert('표를 감지하여 Markdown으로 변환했습니다.');
                }
            });
        }
        
        function convertHtmlTableToMdMarkdown(htmlString) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlString, 'text/html');
            const table = doc.querySelector('table');
            if (!table) return '';
            
            let md = '\n';
            const rows = Array.from(table.querySelectorAll('tr'));
            
            rows.forEach((row, rowIndex) => {
                const cells = Array.from(row.querySelectorAll('th, td'));
                const cellText = cells.map(cell => 
                    cell.textContent.trim().replace(/\|/g, '\\|').replace(/\n/g, ' ')
                );
                if (cellText.length === 0) return;
                md += '| ' + cellText.join(' | ') + ' |\n';
                if (rowIndex === 0) {
                    const separator = cells.map(() => '---'); 
                    md += '| ' + separator.join(' | ') + ' |\n';
                }
            });
            return md + '\n';
        }
        
        // 폰트 크기 조절
        function changeMdFontSize(delta) {
            mdCurrentFontSize += delta;
            if (mdCurrentFontSize < 10) mdCurrentFontSize = 10;
            if (mdCurrentFontSize > 32) mdCurrentFontSize = 32;
            
            if (mdPreviewContent) {
                mdPreviewContent.style.fontSize = `${mdCurrentFontSize}px`;
            }
            if (mdFontSizeDisplay) {
                mdFontSizeDisplay.innerText = `${mdCurrentFontSize}px`;
            }
        }
        
        // 용지 방향 조절
        function changeMdOrientation() {
            if (!mdOrientationSelect || !mdPreviewPaper) return;
            
            mdCurrentOrientation = mdOrientationSelect.value;
            
            if (mdCurrentOrientation === 'portrait') {
                mdPreviewPaper.style.maxWidth = '210mm';
                mdPreviewPaper.style.minHeight = '297mm';
                if (mdPaperSizeLabel) mdPaperSizeLabel.innerText = 'A4 Portrait';
            } else {
                mdPreviewPaper.style.maxWidth = '297mm';
                mdPreviewPaper.style.minHeight = '210mm';
                if (mdPaperSizeLabel) mdPaperSizeLabel.innerText = 'A4 Landscape';
            }
            
            // 인쇄 시 용지 방향 CSS 설정
            mdStyleSheet.innerText = `@page { size: ${mdCurrentOrientation}; margin: 15mm; }`;
        }
        
        // 에디터 지우기
        function clearMdEditor() {
            if (!mdInputText) return;
            if (mdInputText.value.trim() === '') return;
            if (confirm('작성 중인 내용을 모두 지우시겠습니까?')) {
                mdInputText.value = '';
                renderMdMarkdown();
                mdInputText.focus();
            }
        }
        
        // 예제 복구
        function resetMdExample() {
            if (!mdInputText) return;
            if (confirm('작성 중인 내용이 사라집니다. 기본 예제로 초기화하시겠습니까?')) {
                mdInputText.value = mdDefaultExampleText;
                renderMdMarkdown();
            }
        }
        
        // PDF 다운로드 (브라우저 인쇄 모드 사용)
        function downloadMdPDF() {
            alert("인쇄 창에서 'PDF로 저장'을 선택해주세요.\n(대상: PDF로 저장 선택)");
            setTimeout(() => {
                window.print();
            }, 300);
        }
    </script>
    
    <!-- Cross-reference 경고 모달 -->
    <div id="crossRefWarningModal" class="modal-overlay">
        <div class="modal-dialog">
            <div class="modal-header">
                <span class="modal-icon">⚠️</span>
                <span class="modal-title">Cross-reference가 없습니다</span>
            </div>
            <div class="modal-body">
                <p>현재 문서에 <strong>Cross-reference</strong>가 삽입되어 있지 않습니다.</p>
                <p>단락번호는 일반적으로 Cross-reference 단락부터 시작됩니다. 어떻게 진행하시겠습니까?</p>
            </div>
            <div class="modal-buttons">
                <button class="modal-btn modal-btn-primary" onclick="goToCrossRefInsert()">
                    📝 Cross-reference 먼저 삽입하기
                </button>
                <button class="modal-btn modal-btn-secondary" onclick="proceedWithoutCrossRef()">
                    🔢 Cross-reference 없이 단락번호 추가
                </button>
                <button class="modal-btn modal-btn-cancel" onclick="closeModal()">
                    취소
                </button>
            </div>
        </div>
    </div>
    
    <!-- Footer -->
    <footer class="app-footer">
        <span>Document Tools v1.2.0</span>
        <span class="footer-separator">|</span>
        <span>© 2026 Smart Danny. All rights reserved.</span>
    </footer>
</body>
</html>
